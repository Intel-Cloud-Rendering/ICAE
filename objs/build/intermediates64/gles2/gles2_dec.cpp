// Generated Code - DO NOT EDIT !!
// generated by 'emugen'


#include <string.h>
#include "gles2_opcodes.h"

#include "gles2_dec.h"


#include "ProtocolUtils.h"

#include "ChecksumCalculatorThreadInfo.h"

#include <stdio.h>

typedef unsigned int tsize_t; // Target "size_t", which is 32-bit for now. It may or may not be the same as host's size_t when emugen is compiled.

#ifdef OPENGL_DEBUG_PRINTOUT
#  define DEBUG(...) do { if (emugl_cxt_logger) { emugl_cxt_logger(__VA_ARGS__); } } while(0)
#else
#  define DEBUG(...)  ((void)0)
#endif

#ifdef CHECK_GL_ERRORS
#  define SET_LASTCALL(name)  sprintf(lastCall, #name)
#else
#  define SET_LASTCALL(name)
#endif
using namespace emugl;

#define gles2_ARR_NUM (OP_last - OP_glActiveTexture)
int64_t gles2Dec[gles2_ARR_NUM] = {0};
static int gles2CodeCnt = 0;
void outputGles2Dec() {
    if (gles2CodeCnt >= 100) {
        printf("GLES2: ");
        for (int i = 0; i < gles2_ARR_NUM; i++) {
            printf("%d:%ld ", i, gles2Dec[i]);
        }
        printf("\n");
        gles2CodeCnt = 0;
    }
}

size_t gles2_decoder_context_t::decode(void *buf, size_t len, IOStream *stream, ChecksumCalculator* checksumCalc) {
	if (len < 8) return 0; 
#ifdef CHECK_GL_ERRORS
	char lastCall[256] = {0};
#endif
	unsigned char *ptr = (unsigned char *)buf;
	const unsigned char* const end = (const unsigned char*)buf + len;
    const size_t checksumSize = checksumCalc->checksumByteSize();
    const bool useChecksum = checksumSize > 0;
	while (end - ptr >= 8) {
		uint32_t opcode = *(uint32_t *)ptr;   
		int32_t packetLen = *(int32_t *)(ptr + 4);
		if (end - ptr < packetLen) return ptr - (unsigned char*)buf;
        
        if ((opcode >= OP_glActiveTexture) && (opcode <= OP_last)) {
            gles2Dec[opcode - OP_glActiveTexture]++;
            gles2CodeCnt++;
            outputGles2Dec();
        }
		switch(opcode) {
		case OP_glActiveTexture: {
			GLenum var_texture = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glActiveTexture: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glActiveTexture\n", err);
		#endif
			DEBUG("gles2(%p): glActiveTexture(0x%08x )\n", stream, var_texture);
			this->glActiveTexture(var_texture);
			SET_LASTCALL("glActiveTexture");
			break;
		}
		case OP_glAttachShader: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glAttachShader: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glAttachShader\n", err);
		#endif
			DEBUG("gles2(%p): glAttachShader(%u %u )\n", stream, var_program, var_shader);
			this->glAttachShader(var_program, var_shader);
			SET_LASTCALL("glAttachShader");
			break;
		}
		case OP_glBindAttribLocation: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			uint32_t size_name __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_name(ptr + 8 + 4 + 4 + 4, size_name);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_name, ptr + 8 + 4 + 4 + 4 + size_name, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBindAttribLocation: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBindAttribLocation\n", err);
		#endif
			DEBUG("gles2(%p): glBindAttribLocation(%u %u %p(%u) )\n", stream, var_program, var_index, (const GLchar*)(inptr_name.get()), size_name);
			this->glBindAttribLocation(var_program, var_index, (const GLchar*)(inptr_name.get()));
			SET_LASTCALL("glBindAttribLocation");
			break;
		}
		case OP_glBindBuffer: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_buffer = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBindBuffer: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBindBuffer\n", err);
		#endif
			DEBUG("gles2(%p): glBindBuffer(0x%08x %u )\n", stream, var_target, var_buffer);
			this->glBindBuffer(var_target, var_buffer);
			SET_LASTCALL("glBindBuffer");
			break;
		}
		case OP_glBindFramebuffer: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_framebuffer = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBindFramebuffer: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBindFramebuffer\n", err);
		#endif
			DEBUG("gles2(%p): glBindFramebuffer(0x%08x %u )\n", stream, var_target, var_framebuffer);
			this->glBindFramebuffer(var_target, var_framebuffer);
			SET_LASTCALL("glBindFramebuffer");
			break;
		}
		case OP_glBindRenderbuffer: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_renderbuffer = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBindRenderbuffer: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBindRenderbuffer\n", err);
		#endif
			DEBUG("gles2(%p): glBindRenderbuffer(0x%08x %u )\n", stream, var_target, var_renderbuffer);
			this->glBindRenderbuffer(var_target, var_renderbuffer);
			SET_LASTCALL("glBindRenderbuffer");
			break;
		}
		case OP_glBindTexture: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_texture = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBindTexture: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBindTexture\n", err);
		#endif
			DEBUG("gles2(%p): glBindTexture(0x%08x %u )\n", stream, var_target, var_texture);
			this->glBindTexture(var_target, var_texture);
			SET_LASTCALL("glBindTexture");
			break;
		}
		case OP_glBlendColor: {
			GLclampf var_red = Unpack<GLclampf,uint32_t>(ptr + 8);
			GLclampf var_green = Unpack<GLclampf,uint32_t>(ptr + 8 + 4);
			GLclampf var_blue = Unpack<GLclampf,uint32_t>(ptr + 8 + 4 + 4);
			GLclampf var_alpha = Unpack<GLclampf,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBlendColor: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBlendColor\n", err);
		#endif
			DEBUG("gles2(%p): glBlendColor(%f %f %f %f )\n", stream, var_red, var_green, var_blue, var_alpha);
			this->glBlendColor(var_red, var_green, var_blue, var_alpha);
			SET_LASTCALL("glBlendColor");
			break;
		}
		case OP_glBlendEquation: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBlendEquation: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBlendEquation\n", err);
		#endif
			DEBUG("gles2(%p): glBlendEquation(0x%08x )\n", stream, var_mode);
			this->glBlendEquation(var_mode);
			SET_LASTCALL("glBlendEquation");
			break;
		}
		case OP_glBlendEquationSeparate: {
			GLenum var_modeRGB = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_modeAlpha = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBlendEquationSeparate: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBlendEquationSeparate\n", err);
		#endif
			DEBUG("gles2(%p): glBlendEquationSeparate(0x%08x 0x%08x )\n", stream, var_modeRGB, var_modeAlpha);
			this->glBlendEquationSeparate(var_modeRGB, var_modeAlpha);
			SET_LASTCALL("glBlendEquationSeparate");
			break;
		}
		case OP_glBlendFunc: {
			GLenum var_sfactor = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_dfactor = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBlendFunc: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBlendFunc\n", err);
		#endif
			DEBUG("gles2(%p): glBlendFunc(0x%08x 0x%08x )\n", stream, var_sfactor, var_dfactor);
			this->glBlendFunc(var_sfactor, var_dfactor);
			SET_LASTCALL("glBlendFunc");
			break;
		}
		case OP_glBlendFuncSeparate: {
			GLenum var_srcRGB = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_dstRGB = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_srcAlpha = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLenum var_dstAlpha = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBlendFuncSeparate: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBlendFuncSeparate\n", err);
		#endif
			DEBUG("gles2(%p): glBlendFuncSeparate(0x%08x 0x%08x 0x%08x 0x%08x )\n", stream, var_srcRGB, var_dstRGB, var_srcAlpha, var_dstAlpha);
			this->glBlendFuncSeparate(var_srcRGB, var_dstRGB, var_srcAlpha, var_dstAlpha);
			SET_LASTCALL("glBlendFuncSeparate");
			break;
		}
		case OP_glBufferData: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizeiptr var_size = Unpack<GLsizeiptr,uint32_t>(ptr + 8 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4, size_data);
			GLenum var_usage = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_data + 4, ptr + 8 + 4 + 4 + 4 + size_data + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBufferData: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBufferData\n", err);
		#endif
			DEBUG("gles2(%p): glBufferData(0x%08x 0x%08lx %p(%u) 0x%08x )\n", stream, var_target, var_size, (const GLvoid*)(inptr_data.get()), size_data, var_usage);
			this->glBufferData(var_target, var_size, size_data == 0 ? nullptr : (const GLvoid*)(inptr_data.get()), var_usage);
			SET_LASTCALL("glBufferData");
			break;
		}
		case OP_glBufferSubData: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLintptr var_offset = Unpack<GLintptr,uint32_t>(ptr + 8 + 4);
			GLsizeiptr var_size = Unpack<GLsizeiptr,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBufferSubData: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBufferSubData\n", err);
		#endif
			DEBUG("gles2(%p): glBufferSubData(0x%08x 0x%08lx 0x%08lx %p(%u) )\n", stream, var_target, var_offset, var_size, (const GLvoid*)(inptr_data.get()), size_data);
			this->glBufferSubData(var_target, var_offset, var_size, size_data == 0 ? nullptr : (const GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glBufferSubData");
			break;
		}
		case OP_glCheckFramebufferStatus: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCheckFramebufferStatus: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLenum);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCheckFramebufferStatus\n", err);
		#endif
			DEBUG("gles2(%p): glCheckFramebufferStatus(0x%08x )\n", stream, var_target);
			*(GLenum *)(&tmpBuf[0]) = 			this->glCheckFramebufferStatus(var_target);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glCheckFramebufferStatus");
			break;
		}
		case OP_glClear: {
			GLbitfield var_mask = Unpack<GLbitfield,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glClear: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glClear\n", err);
		#endif
			DEBUG("gles2(%p): glClear(0x%08x )\n", stream, var_mask);
			this->glClear(var_mask);
			SET_LASTCALL("glClear");
			break;
		}
		case OP_glClearColor: {
			GLclampf var_red = Unpack<GLclampf,uint32_t>(ptr + 8);
			GLclampf var_green = Unpack<GLclampf,uint32_t>(ptr + 8 + 4);
			GLclampf var_blue = Unpack<GLclampf,uint32_t>(ptr + 8 + 4 + 4);
			GLclampf var_alpha = Unpack<GLclampf,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glClearColor: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glClearColor\n", err);
		#endif
			DEBUG("gles2(%p): glClearColor(%f %f %f %f )\n", stream, var_red, var_green, var_blue, var_alpha);
			this->glClearColor(var_red, var_green, var_blue, var_alpha);
			SET_LASTCALL("glClearColor");
			break;
		}
		case OP_glClearDepthf: {
			GLclampf var_depth = Unpack<GLclampf,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glClearDepthf: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glClearDepthf\n", err);
		#endif
			DEBUG("gles2(%p): glClearDepthf(%f )\n", stream, var_depth);
			this->glClearDepthf(var_depth);
			SET_LASTCALL("glClearDepthf");
			break;
		}
		case OP_glClearStencil: {
			GLint var_s = Unpack<GLint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glClearStencil: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glClearStencil\n", err);
		#endif
			DEBUG("gles2(%p): glClearStencil(%d )\n", stream, var_s);
			this->glClearStencil(var_s);
			SET_LASTCALL("glClearStencil");
			break;
		}
		case OP_glColorMask: {
			GLboolean var_red = Unpack<GLboolean,uint8_t>(ptr + 8);
			GLboolean var_green = Unpack<GLboolean,uint8_t>(ptr + 8 + 1);
			GLboolean var_blue = Unpack<GLboolean,uint8_t>(ptr + 8 + 1 + 1);
			GLboolean var_alpha = Unpack<GLboolean,uint8_t>(ptr + 8 + 1 + 1 + 1);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 1 + 1 + 1 + 1, ptr + 8 + 1 + 1 + 1 + 1, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glColorMask: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glColorMask\n", err);
		#endif
			DEBUG("gles2(%p): glColorMask(%d %d %d %d )\n", stream, var_red, var_green, var_blue, var_alpha);
			this->glColorMask(var_red, var_green, var_blue, var_alpha);
			SET_LASTCALL("glColorMask");
			break;
		}
		case OP_glCompileShader: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCompileShader: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCompileShader\n", err);
		#endif
			DEBUG("gles2(%p): glCompileShader(%u )\n", stream, var_shader);
			this->glCompileShader(var_shader);
			SET_LASTCALL("glCompileShader");
			break;
		}
		case OP_glCompressedTexImage2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_imageSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCompressedTexImage2D: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCompressedTexImage2D\n", err);
		#endif
			DEBUG("gles2(%p): glCompressedTexImage2D(0x%08x %d 0x%08x %d %d %d %d %p(%u) )\n", stream, var_target, var_level, var_internalformat, var_width, var_height, var_border, var_imageSize, (const GLvoid*)(inptr_data.get()), size_data);
			this->glCompressedTexImage2D(var_target, var_level, var_internalformat, var_width, var_height, var_border, var_imageSize, size_data == 0 ? nullptr : (const GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glCompressedTexImage2D");
			break;
		}
		case OP_glCompressedTexSubImage2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_imageSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCompressedTexSubImage2D: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCompressedTexSubImage2D\n", err);
		#endif
			DEBUG("gles2(%p): glCompressedTexSubImage2D(0x%08x %d %d %d %d %d 0x%08x %d %p(%u) )\n", stream, var_target, var_level, var_xoffset, var_yoffset, var_width, var_height, var_format, var_imageSize, (const GLvoid*)(inptr_data.get()), size_data);
			this->glCompressedTexSubImage2D(var_target, var_level, var_xoffset, var_yoffset, var_width, var_height, var_format, var_imageSize, size_data == 0 ? nullptr : (const GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glCompressedTexSubImage2D");
			break;
		}
		case OP_glCopyTexImage2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCopyTexImage2D: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCopyTexImage2D\n", err);
		#endif
			DEBUG("gles2(%p): glCopyTexImage2D(0x%08x %d 0x%08x %d %d %d %d %d )\n", stream, var_target, var_level, var_internalformat, var_x, var_y, var_width, var_height, var_border);
			this->glCopyTexImage2D(var_target, var_level, var_internalformat, var_x, var_y, var_width, var_height, var_border);
			SET_LASTCALL("glCopyTexImage2D");
			break;
		}
		case OP_glCopyTexSubImage2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCopyTexSubImage2D: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCopyTexSubImage2D\n", err);
		#endif
			DEBUG("gles2(%p): glCopyTexSubImage2D(0x%08x %d %d %d %d %d %d %d )\n", stream, var_target, var_level, var_xoffset, var_yoffset, var_x, var_y, var_width, var_height);
			this->glCopyTexSubImage2D(var_target, var_level, var_xoffset, var_yoffset, var_x, var_y, var_width, var_height);
			SET_LASTCALL("glCopyTexSubImage2D");
			break;
		}
		case OP_glCreateProgram: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8, ptr + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCreateProgram: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLuint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCreateProgram\n", err);
		#endif
			DEBUG("gles2(%p): glCreateProgram()\n", stream);
			*(GLuint *)(&tmpBuf[0]) = 			this->glCreateProgram();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glCreateProgram");
			break;
		}
		case OP_glCreateShader: {
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCreateShader: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLuint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCreateShader\n", err);
		#endif
			DEBUG("gles2(%p): glCreateShader(0x%08x )\n", stream, var_type);
			*(GLuint *)(&tmpBuf[0]) = 			this->glCreateShader(var_type);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glCreateShader");
			break;
		}
		case OP_glCullFace: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCullFace: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCullFace\n", err);
		#endif
			DEBUG("gles2(%p): glCullFace(0x%08x )\n", stream, var_mode);
			this->glCullFace(var_mode);
			SET_LASTCALL("glCullFace");
			break;
		}
		case OP_glDeleteBuffers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_buffers __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_buffers(ptr + 8 + 4 + 4, size_buffers);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_buffers, ptr + 8 + 4 + 4 + size_buffers, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteBuffers: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteBuffers\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteBuffers(%d %p(%u) )\n", stream, var_n, (const GLuint*)(inptr_buffers.get()), size_buffers);
			this->glDeleteBuffers(var_n, (const GLuint*)(inptr_buffers.get()));
			SET_LASTCALL("glDeleteBuffers");
			break;
		}
		case OP_glDeleteFramebuffers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_framebuffers __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_framebuffers(ptr + 8 + 4 + 4, size_framebuffers);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_framebuffers, ptr + 8 + 4 + 4 + size_framebuffers, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteFramebuffers: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteFramebuffers\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteFramebuffers(%d %p(%u) )\n", stream, var_n, (const GLuint*)(inptr_framebuffers.get()), size_framebuffers);
			this->glDeleteFramebuffers(var_n, (const GLuint*)(inptr_framebuffers.get()));
			SET_LASTCALL("glDeleteFramebuffers");
			break;
		}
		case OP_glDeleteProgram: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteProgram: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteProgram\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteProgram(%u )\n", stream, var_program);
			this->glDeleteProgram(var_program);
			SET_LASTCALL("glDeleteProgram");
			break;
		}
		case OP_glDeleteRenderbuffers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_renderbuffers __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_renderbuffers(ptr + 8 + 4 + 4, size_renderbuffers);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_renderbuffers, ptr + 8 + 4 + 4 + size_renderbuffers, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteRenderbuffers: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteRenderbuffers\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteRenderbuffers(%d %p(%u) )\n", stream, var_n, (const GLuint*)(inptr_renderbuffers.get()), size_renderbuffers);
			this->glDeleteRenderbuffers(var_n, (const GLuint*)(inptr_renderbuffers.get()));
			SET_LASTCALL("glDeleteRenderbuffers");
			break;
		}
		case OP_glDeleteShader: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteShader: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteShader\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteShader(%u )\n", stream, var_shader);
			this->glDeleteShader(var_shader);
			SET_LASTCALL("glDeleteShader");
			break;
		}
		case OP_glDeleteTextures: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_textures __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_textures(ptr + 8 + 4 + 4, size_textures);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_textures, ptr + 8 + 4 + 4 + size_textures, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteTextures: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteTextures\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteTextures(%d %p(%u) )\n", stream, var_n, (const GLuint*)(inptr_textures.get()), size_textures);
			this->glDeleteTextures(var_n, (const GLuint*)(inptr_textures.get()));
			SET_LASTCALL("glDeleteTextures");
			break;
		}
		case OP_glDepthFunc: {
			GLenum var_func = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDepthFunc: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDepthFunc\n", err);
		#endif
			DEBUG("gles2(%p): glDepthFunc(0x%08x )\n", stream, var_func);
			this->glDepthFunc(var_func);
			SET_LASTCALL("glDepthFunc");
			break;
		}
		case OP_glDepthMask: {
			GLboolean var_flag = Unpack<GLboolean,uint8_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 1, ptr + 8 + 1, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDepthMask: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDepthMask\n", err);
		#endif
			DEBUG("gles2(%p): glDepthMask(%d )\n", stream, var_flag);
			this->glDepthMask(var_flag);
			SET_LASTCALL("glDepthMask");
			break;
		}
		case OP_glDepthRangef: {
			GLclampf var_zNear = Unpack<GLclampf,uint32_t>(ptr + 8);
			GLclampf var_zFar = Unpack<GLclampf,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDepthRangef: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDepthRangef\n", err);
		#endif
			DEBUG("gles2(%p): glDepthRangef(%f %f )\n", stream, var_zNear, var_zFar);
			this->glDepthRangef(var_zNear, var_zFar);
			SET_LASTCALL("glDepthRangef");
			break;
		}
		case OP_glDetachShader: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDetachShader: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDetachShader\n", err);
		#endif
			DEBUG("gles2(%p): glDetachShader(%u %u )\n", stream, var_program, var_shader);
			this->glDetachShader(var_program, var_shader);
			SET_LASTCALL("glDetachShader");
			break;
		}
		case OP_glDisable: {
			GLenum var_cap = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDisable: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDisable\n", err);
		#endif
			DEBUG("gles2(%p): glDisable(0x%08x )\n", stream, var_cap);
			this->glDisable(var_cap);
			SET_LASTCALL("glDisable");
			break;
		}
		case OP_glDisableVertexAttribArray: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDisableVertexAttribArray: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDisableVertexAttribArray\n", err);
		#endif
			DEBUG("gles2(%p): glDisableVertexAttribArray(%u )\n", stream, var_index);
			this->glDisableVertexAttribArray(var_index);
			SET_LASTCALL("glDisableVertexAttribArray");
			break;
		}
		case OP_glDrawArrays: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_first = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawArrays: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawArrays\n", err);
		#endif
			DEBUG("gles2(%p): glDrawArrays(0x%08x %d %d )\n", stream, var_mode, var_first, var_count);
			this->glDrawArrays(var_mode, var_first, var_count);
			SET_LASTCALL("glDrawArrays");
			break;
		}
		case OP_glDrawElements: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_indices __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_indices(ptr + 8 + 4 + 4 + 4 + 4, size_indices);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_indices, ptr + 8 + 4 + 4 + 4 + 4 + size_indices, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawElements: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawElements\n", err);
		#endif
			DEBUG("gles2(%p): glDrawElements(0x%08x %d 0x%08x %p(%u) )\n", stream, var_mode, var_count, var_type, (const GLvoid*)(inptr_indices.get()), size_indices);
			this->glDrawElements(var_mode, var_count, var_type, (const GLvoid*)(inptr_indices.get()));
			SET_LASTCALL("glDrawElements");
			break;
		}
		case OP_glEnable: {
			GLenum var_cap = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glEnable: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glEnable\n", err);
		#endif
			DEBUG("gles2(%p): glEnable(0x%08x )\n", stream, var_cap);
			this->glEnable(var_cap);
			SET_LASTCALL("glEnable");
			break;
		}
		case OP_glEnableVertexAttribArray: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glEnableVertexAttribArray: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glEnableVertexAttribArray\n", err);
		#endif
			DEBUG("gles2(%p): glEnableVertexAttribArray(%u )\n", stream, var_index);
			this->glEnableVertexAttribArray(var_index);
			SET_LASTCALL("glEnableVertexAttribArray");
			break;
		}
		case OP_glFinish: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8, ptr + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFinish: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFinish\n", err);
		#endif
			DEBUG("gles2(%p): glFinish()\n", stream);
			this->glFinish();
			SET_LASTCALL("glFinish");
			break;
		}
		case OP_glFlush: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8, ptr + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFlush: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFlush\n", err);
		#endif
			DEBUG("gles2(%p): glFlush()\n", stream);
			this->glFlush();
			SET_LASTCALL("glFlush");
			break;
		}
		case OP_glFramebufferRenderbuffer: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_attachment = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_renderbuffertarget = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_renderbuffer = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFramebufferRenderbuffer: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFramebufferRenderbuffer\n", err);
		#endif
			DEBUG("gles2(%p): glFramebufferRenderbuffer(0x%08x 0x%08x 0x%08x %u )\n", stream, var_target, var_attachment, var_renderbuffertarget, var_renderbuffer);
			this->glFramebufferRenderbuffer(var_target, var_attachment, var_renderbuffertarget, var_renderbuffer);
			SET_LASTCALL("glFramebufferRenderbuffer");
			break;
		}
		case OP_glFramebufferTexture2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_attachment = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_textarget = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_texture = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFramebufferTexture2D: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFramebufferTexture2D\n", err);
		#endif
			DEBUG("gles2(%p): glFramebufferTexture2D(0x%08x 0x%08x 0x%08x %u %d )\n", stream, var_target, var_attachment, var_textarget, var_texture, var_level);
			this->glFramebufferTexture2D(var_target, var_attachment, var_textarget, var_texture, var_level);
			SET_LASTCALL("glFramebufferTexture2D");
			break;
		}
		case OP_glFrontFace: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFrontFace: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFrontFace\n", err);
		#endif
			DEBUG("gles2(%p): glFrontFace(0x%08x )\n", stream, var_mode);
			this->glFrontFace(var_mode);
			SET_LASTCALL("glFrontFace");
			break;
		}
		case OP_glGenBuffers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_buffers __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGenBuffers: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_buffers;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_buffers(&tmpBuf[0], size_buffers);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGenBuffers\n", err);
		#endif
			DEBUG("gles2(%p): glGenBuffers(%d %p(%u) )\n", stream, var_n, (GLuint*)(outptr_buffers.get()), size_buffers);
			this->glGenBuffers(var_n, (GLuint*)(outptr_buffers.get()));
			outptr_buffers.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenBuffers");
			break;
		}
		case OP_glGenerateMipmap: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGenerateMipmap: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGenerateMipmap\n", err);
		#endif
			DEBUG("gles2(%p): glGenerateMipmap(0x%08x )\n", stream, var_target);
			this->glGenerateMipmap(var_target);
			SET_LASTCALL("glGenerateMipmap");
			break;
		}
		case OP_glGenFramebuffers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_framebuffers __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGenFramebuffers: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_framebuffers;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_framebuffers(&tmpBuf[0], size_framebuffers);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGenFramebuffers\n", err);
		#endif
			DEBUG("gles2(%p): glGenFramebuffers(%d %p(%u) )\n", stream, var_n, (GLuint*)(outptr_framebuffers.get()), size_framebuffers);
			this->glGenFramebuffers(var_n, (GLuint*)(outptr_framebuffers.get()));
			outptr_framebuffers.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenFramebuffers");
			break;
		}
		case OP_glGenRenderbuffers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_renderbuffers __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGenRenderbuffers: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_renderbuffers;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_renderbuffers(&tmpBuf[0], size_renderbuffers);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGenRenderbuffers\n", err);
		#endif
			DEBUG("gles2(%p): glGenRenderbuffers(%d %p(%u) )\n", stream, var_n, (GLuint*)(outptr_renderbuffers.get()), size_renderbuffers);
			this->glGenRenderbuffers(var_n, (GLuint*)(outptr_renderbuffers.get()));
			outptr_renderbuffers.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenRenderbuffers");
			break;
		}
		case OP_glGenTextures: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_textures __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGenTextures: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_textures;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_textures(&tmpBuf[0], size_textures);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGenTextures\n", err);
		#endif
			DEBUG("gles2(%p): glGenTextures(%d %p(%u) )\n", stream, var_n, (GLuint*)(outptr_textures.get()), size_textures);
			this->glGenTextures(var_n, (GLuint*)(outptr_textures.get()));
			outptr_textures.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenTextures");
			break;
		}
		case OP_glGetActiveAttrib: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLsizei var_bufsize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_size __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			uint32_t size_type __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_name __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetActiveAttrib: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_size;
			totalTmpSize += size_type;
			totalTmpSize += size_name;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_size(&tmpBuf[0 + size_length], size_size);
			OutputBuffer outptr_type(&tmpBuf[0 + size_length + size_size], size_type);
			OutputBuffer outptr_name(&tmpBuf[0 + size_length + size_size + size_type], size_name);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetActiveAttrib\n", err);
		#endif
			DEBUG("gles2(%p): glGetActiveAttrib(%u %u %d %p(%u) %p(%u) %p(%u) %p(%u) )\n", stream, var_program, var_index, var_bufsize, (GLsizei*)(outptr_length.get()), size_length, (GLint*)(outptr_size.get()), size_size, (GLenum*)(outptr_type.get()), size_type, (GLchar*)(outptr_name.get()), size_name);
			this->glGetActiveAttrib(var_program, var_index, var_bufsize, size_length == 0 ? nullptr : (GLsizei*)(outptr_length.get()), size_size == 0 ? nullptr : (GLint*)(outptr_size.get()), size_type == 0 ? nullptr : (GLenum*)(outptr_type.get()), size_name == 0 ? nullptr : (GLchar*)(outptr_name.get()));
			outptr_length.flush();
			outptr_size.flush();
			outptr_type.flush();
			outptr_name.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetActiveAttrib");
			break;
		}
		case OP_glGetActiveUniform: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLsizei var_bufsize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_size __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			uint32_t size_type __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_name __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetActiveUniform: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_size;
			totalTmpSize += size_type;
			totalTmpSize += size_name;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_size(&tmpBuf[0 + size_length], size_size);
			OutputBuffer outptr_type(&tmpBuf[0 + size_length + size_size], size_type);
			OutputBuffer outptr_name(&tmpBuf[0 + size_length + size_size + size_type], size_name);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetActiveUniform\n", err);
		#endif
			DEBUG("gles2(%p): glGetActiveUniform(%u %u %d %p(%u) %p(%u) %p(%u) %p(%u) )\n", stream, var_program, var_index, var_bufsize, (GLsizei*)(outptr_length.get()), size_length, (GLint*)(outptr_size.get()), size_size, (GLenum*)(outptr_type.get()), size_type, (GLchar*)(outptr_name.get()), size_name);
			this->glGetActiveUniform(var_program, var_index, var_bufsize, size_length == 0 ? nullptr : (GLsizei*)(outptr_length.get()), size_size == 0 ? nullptr : (GLint*)(outptr_size.get()), size_type == 0 ? nullptr : (GLenum*)(outptr_type.get()), size_name == 0 ? nullptr : (GLchar*)(outptr_name.get()));
			outptr_length.flush();
			outptr_size.flush();
			outptr_type.flush();
			outptr_name.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetActiveUniform");
			break;
		}
		case OP_glGetAttachedShaders: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_maxcount = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_count __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_shaders __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetAttachedShaders: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_count;
			totalTmpSize += size_shaders;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_count(&tmpBuf[0], size_count);
			OutputBuffer outptr_shaders(&tmpBuf[0 + size_count], size_shaders);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetAttachedShaders\n", err);
		#endif
			DEBUG("gles2(%p): glGetAttachedShaders(%u %d %p(%u) %p(%u) )\n", stream, var_program, var_maxcount, (GLsizei*)(outptr_count.get()), size_count, (GLuint*)(outptr_shaders.get()), size_shaders);
			this->glGetAttachedShaders(var_program, var_maxcount, size_count == 0 ? nullptr : (GLsizei*)(outptr_count.get()), (GLuint*)(outptr_shaders.get()));
			outptr_count.flush();
			outptr_shaders.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetAttachedShaders");
			break;
		}
		case OP_glGetAttribLocation: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_name __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_name(ptr + 8 + 4 + 4, size_name);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_name, ptr + 8 + 4 + 4 + size_name, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetAttribLocation: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetAttribLocation\n", err);
		#endif
			DEBUG("gles2(%p): glGetAttribLocation(%u %p(%u) )\n", stream, var_program, (const GLchar*)(inptr_name.get()), size_name);
			*(int *)(&tmpBuf[0]) = 			this->glGetAttribLocation(var_program, (const GLchar*)(inptr_name.get()));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetAttribLocation");
			break;
		}
		case OP_glGetBooleanv: {
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetBooleanv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetBooleanv\n", err);
		#endif
			DEBUG("gles2(%p): glGetBooleanv(0x%08x %p(%u) )\n", stream, var_pname, (GLboolean*)(outptr_params.get()), size_params);
			this->glGetBooleanv(var_pname, (GLboolean*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetBooleanv");
			break;
		}
		case OP_glGetBufferParameteriv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetBufferParameteriv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetBufferParameteriv\n", err);
		#endif
			DEBUG("gles2(%p): glGetBufferParameteriv(0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetBufferParameteriv(var_target, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetBufferParameteriv");
			break;
		}
		case OP_glGetError: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8, ptr + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetError: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLenum);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetError\n", err);
		#endif
			DEBUG("gles2(%p): glGetError()\n", stream);
			*(GLenum *)(&tmpBuf[0]) = 			this->glGetError();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetError");
			break;
		}
		case OP_glGetFloatv: {
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetFloatv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetFloatv\n", err);
		#endif
			DEBUG("gles2(%p): glGetFloatv(0x%08x %p(%u) )\n", stream, var_pname, (GLfloat*)(outptr_params.get()), size_params);
			this->glGetFloatv(var_pname, (GLfloat*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetFloatv");
			break;
		}
		case OP_glGetFramebufferAttachmentParameteriv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_attachment = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetFramebufferAttachmentParameteriv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetFramebufferAttachmentParameteriv\n", err);
		#endif
			DEBUG("gles2(%p): glGetFramebufferAttachmentParameteriv(0x%08x 0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_attachment, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetFramebufferAttachmentParameteriv(var_target, var_attachment, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetFramebufferAttachmentParameteriv");
			break;
		}
		case OP_glGetIntegerv: {
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetIntegerv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetIntegerv\n", err);
		#endif
			DEBUG("gles2(%p): glGetIntegerv(0x%08x %p(%u) )\n", stream, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetIntegerv(var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetIntegerv");
			break;
		}
		case OP_glGetProgramiv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetProgramiv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetProgramiv\n", err);
		#endif
			DEBUG("gles2(%p): glGetProgramiv(%u 0x%08x %p(%u) )\n", stream, var_program, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetProgramiv(var_program, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetProgramiv");
			break;
		}
		case OP_glGetProgramInfoLog: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_bufsize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_infolog __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetProgramInfoLog: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_infolog;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_infolog(&tmpBuf[0 + size_length], size_infolog);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetProgramInfoLog\n", err);
		#endif
			DEBUG("gles2(%p): glGetProgramInfoLog(%u %d %p(%u) %p(%u) )\n", stream, var_program, var_bufsize, (GLsizei*)(outptr_length.get()), size_length, (GLchar*)(outptr_infolog.get()), size_infolog);
			this->glGetProgramInfoLog(var_program, var_bufsize, size_length == 0 ? nullptr : (GLsizei*)(outptr_length.get()), (GLchar*)(outptr_infolog.get()));
			outptr_length.flush();
			outptr_infolog.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetProgramInfoLog");
			break;
		}
		case OP_glGetRenderbufferParameteriv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetRenderbufferParameteriv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetRenderbufferParameteriv\n", err);
		#endif
			DEBUG("gles2(%p): glGetRenderbufferParameteriv(0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetRenderbufferParameteriv(var_target, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetRenderbufferParameteriv");
			break;
		}
		case OP_glGetShaderiv: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetShaderiv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetShaderiv\n", err);
		#endif
			DEBUG("gles2(%p): glGetShaderiv(%u 0x%08x %p(%u) )\n", stream, var_shader, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetShaderiv(var_shader, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetShaderiv");
			break;
		}
		case OP_glGetShaderInfoLog: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_bufsize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_infolog __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetShaderInfoLog: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_infolog;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_infolog(&tmpBuf[0 + size_length], size_infolog);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetShaderInfoLog\n", err);
		#endif
			DEBUG("gles2(%p): glGetShaderInfoLog(%u %d %p(%u) %p(%u) )\n", stream, var_shader, var_bufsize, (GLsizei*)(outptr_length.get()), size_length, (GLchar*)(outptr_infolog.get()), size_infolog);
			this->glGetShaderInfoLog(var_shader, var_bufsize, size_length == 0 ? nullptr : (GLsizei*)(outptr_length.get()), (GLchar*)(outptr_infolog.get()));
			outptr_length.flush();
			outptr_infolog.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetShaderInfoLog");
			break;
		}
		case OP_glGetShaderPrecisionFormat: {
			GLenum var_shadertype = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_precisiontype = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_range __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_precision __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetShaderPrecisionFormat: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_range;
			totalTmpSize += size_precision;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_range(&tmpBuf[0], size_range);
			OutputBuffer outptr_precision(&tmpBuf[0 + size_range], size_precision);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetShaderPrecisionFormat\n", err);
		#endif
			DEBUG("gles2(%p): glGetShaderPrecisionFormat(0x%08x 0x%08x %p(%u) %p(%u) )\n", stream, var_shadertype, var_precisiontype, (GLint*)(outptr_range.get()), size_range, (GLint*)(outptr_precision.get()), size_precision);
			this->glGetShaderPrecisionFormat(var_shadertype, var_precisiontype, (GLint*)(outptr_range.get()), (GLint*)(outptr_precision.get()));
			outptr_range.flush();
			outptr_precision.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetShaderPrecisionFormat");
			break;
		}
		case OP_glGetShaderSource: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_bufsize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_source __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetShaderSource: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_source;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_source(&tmpBuf[0 + size_length], size_source);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetShaderSource\n", err);
		#endif
			DEBUG("gles2(%p): glGetShaderSource(%u %d %p(%u) %p(%u) )\n", stream, var_shader, var_bufsize, (GLsizei*)(outptr_length.get()), size_length, (GLchar*)(outptr_source.get()), size_source);
			this->glGetShaderSource(var_shader, var_bufsize, size_length == 0 ? nullptr : (GLsizei*)(outptr_length.get()), (GLchar*)(outptr_source.get()));
			outptr_length.flush();
			outptr_source.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetShaderSource");
			break;
		}
		case OP_glGetString: {
			GLenum var_name = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetString: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetString\n", err);
		#endif
			DEBUG("gles2(%p): glGetString(0x%08x )\n", stream, var_name);
			this->glGetString(var_name);
			SET_LASTCALL("glGetString");
			break;
		}
		case OP_glGetTexParameterfv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetTexParameterfv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetTexParameterfv\n", err);
		#endif
			DEBUG("gles2(%p): glGetTexParameterfv(0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_pname, (GLfloat*)(outptr_params.get()), size_params);
			this->glGetTexParameterfv(var_target, var_pname, (GLfloat*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetTexParameterfv");
			break;
		}
		case OP_glGetTexParameteriv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetTexParameteriv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetTexParameteriv\n", err);
		#endif
			DEBUG("gles2(%p): glGetTexParameteriv(0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetTexParameteriv(var_target, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetTexParameteriv");
			break;
		}
		case OP_glGetUniformfv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetUniformfv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetUniformfv\n", err);
		#endif
			DEBUG("gles2(%p): glGetUniformfv(%u %d %p(%u) )\n", stream, var_program, var_location, (GLfloat*)(outptr_params.get()), size_params);
			this->glGetUniformfv(var_program, var_location, (GLfloat*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetUniformfv");
			break;
		}
		case OP_glGetUniformiv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetUniformiv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetUniformiv\n", err);
		#endif
			DEBUG("gles2(%p): glGetUniformiv(%u %d %p(%u) )\n", stream, var_program, var_location, (GLint*)(outptr_params.get()), size_params);
			this->glGetUniformiv(var_program, var_location, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetUniformiv");
			break;
		}
		case OP_glGetUniformLocation: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_name __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_name(ptr + 8 + 4 + 4, size_name);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_name, ptr + 8 + 4 + 4 + size_name, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetUniformLocation: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetUniformLocation\n", err);
		#endif
			DEBUG("gles2(%p): glGetUniformLocation(%u %p(%u) )\n", stream, var_program, (const GLchar*)(inptr_name.get()), size_name);
			*(int *)(&tmpBuf[0]) = 			this->glGetUniformLocation(var_program, (const GLchar*)(inptr_name.get()));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetUniformLocation");
			break;
		}
		case OP_glGetVertexAttribfv: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetVertexAttribfv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetVertexAttribfv\n", err);
		#endif
			DEBUG("gles2(%p): glGetVertexAttribfv(%u 0x%08x %p(%u) )\n", stream, var_index, var_pname, (GLfloat*)(outptr_params.get()), size_params);
			this->glGetVertexAttribfv(var_index, var_pname, (GLfloat*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetVertexAttribfv");
			break;
		}
		case OP_glGetVertexAttribiv: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetVertexAttribiv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetVertexAttribiv\n", err);
		#endif
			DEBUG("gles2(%p): glGetVertexAttribiv(%u 0x%08x %p(%u) )\n", stream, var_index, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetVertexAttribiv(var_index, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetVertexAttribiv");
			break;
		}
		case OP_glGetVertexAttribPointerv: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_pointer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_pointer(ptr + 8 + 4 + 4 + 4, size_pointer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_pointer, ptr + 8 + 4 + 4 + 4 + size_pointer, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetVertexAttribPointerv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetVertexAttribPointerv\n", err);
		#endif
			DEBUG("gles2(%p): glGetVertexAttribPointerv(%u 0x%08x %p(%u) )\n", stream, var_index, var_pname, (GLvoid**)(inptr_pointer.get()), size_pointer);
			this->glGetVertexAttribPointerv(var_index, var_pname, (GLvoid**)(inptr_pointer.get()));
			SET_LASTCALL("glGetVertexAttribPointerv");
			break;
		}
		case OP_glHint: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glHint: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glHint\n", err);
		#endif
			DEBUG("gles2(%p): glHint(0x%08x 0x%08x )\n", stream, var_target, var_mode);
			this->glHint(var_target, var_mode);
			SET_LASTCALL("glHint");
			break;
		}
		case OP_glIsBuffer: {
			GLuint var_buffer = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsBuffer: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsBuffer\n", err);
		#endif
			DEBUG("gles2(%p): glIsBuffer(%u )\n", stream, var_buffer);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsBuffer(var_buffer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsBuffer");
			break;
		}
		case OP_glIsEnabled: {
			GLenum var_cap = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsEnabled: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsEnabled\n", err);
		#endif
			DEBUG("gles2(%p): glIsEnabled(0x%08x )\n", stream, var_cap);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsEnabled(var_cap);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsEnabled");
			break;
		}
		case OP_glIsFramebuffer: {
			GLuint var_framebuffer = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsFramebuffer: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsFramebuffer\n", err);
		#endif
			DEBUG("gles2(%p): glIsFramebuffer(%u )\n", stream, var_framebuffer);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsFramebuffer(var_framebuffer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsFramebuffer");
			break;
		}
		case OP_glIsProgram: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsProgram: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsProgram\n", err);
		#endif
			DEBUG("gles2(%p): glIsProgram(%u )\n", stream, var_program);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsProgram(var_program);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsProgram");
			break;
		}
		case OP_glIsRenderbuffer: {
			GLuint var_renderbuffer = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsRenderbuffer: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsRenderbuffer\n", err);
		#endif
			DEBUG("gles2(%p): glIsRenderbuffer(%u )\n", stream, var_renderbuffer);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsRenderbuffer(var_renderbuffer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsRenderbuffer");
			break;
		}
		case OP_glIsShader: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsShader: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsShader\n", err);
		#endif
			DEBUG("gles2(%p): glIsShader(%u )\n", stream, var_shader);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsShader(var_shader);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsShader");
			break;
		}
		case OP_glIsTexture: {
			GLuint var_texture = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsTexture: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsTexture\n", err);
		#endif
			DEBUG("gles2(%p): glIsTexture(%u )\n", stream, var_texture);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsTexture(var_texture);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsTexture");
			break;
		}
		case OP_glLineWidth: {
			GLfloat var_width = Unpack<GLfloat,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glLineWidth: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glLineWidth\n", err);
		#endif
			DEBUG("gles2(%p): glLineWidth(%f )\n", stream, var_width);
			this->glLineWidth(var_width);
			SET_LASTCALL("glLineWidth");
			break;
		}
		case OP_glLinkProgram: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glLinkProgram: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glLinkProgram\n", err);
		#endif
			DEBUG("gles2(%p): glLinkProgram(%u )\n", stream, var_program);
			this->glLinkProgram(var_program);
			SET_LASTCALL("glLinkProgram");
			break;
		}
		case OP_glPixelStorei: {
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_param = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glPixelStorei: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glPixelStorei\n", err);
		#endif
			DEBUG("gles2(%p): glPixelStorei(0x%08x %d )\n", stream, var_pname, var_param);
			this->glPixelStorei(var_pname, var_param);
			SET_LASTCALL("glPixelStorei");
			break;
		}
		case OP_glPolygonOffset: {
			GLfloat var_factor = Unpack<GLfloat,uint32_t>(ptr + 8);
			GLfloat var_units = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glPolygonOffset: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glPolygonOffset\n", err);
		#endif
			DEBUG("gles2(%p): glPolygonOffset(%f %f )\n", stream, var_factor, var_units);
			this->glPolygonOffset(var_factor, var_units);
			SET_LASTCALL("glPolygonOffset");
			break;
		}
		case OP_glReadPixels: {
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_pixels __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glReadPixels: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_pixels;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_pixels(&tmpBuf[0], size_pixels);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glReadPixels\n", err);
		#endif
			DEBUG("gles2(%p): glReadPixels(%d %d %d %d 0x%08x 0x%08x %p(%u) )\n", stream, var_x, var_y, var_width, var_height, var_format, var_type, (GLvoid*)(outptr_pixels.get()), size_pixels);
			this->glReadPixels(var_x, var_y, var_width, var_height, var_format, var_type, (GLvoid*)(outptr_pixels.get()));
			outptr_pixels.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glReadPixels");
			break;
		}
		case OP_glReleaseShaderCompiler: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8, ptr + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glReleaseShaderCompiler: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glReleaseShaderCompiler\n", err);
		#endif
			DEBUG("gles2(%p): glReleaseShaderCompiler()\n", stream);
			this->glReleaseShaderCompiler();
			SET_LASTCALL("glReleaseShaderCompiler");
			break;
		}
		case OP_glRenderbufferStorage: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glRenderbufferStorage: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glRenderbufferStorage\n", err);
		#endif
			DEBUG("gles2(%p): glRenderbufferStorage(0x%08x 0x%08x %d %d )\n", stream, var_target, var_internalformat, var_width, var_height);
			this->glRenderbufferStorage(var_target, var_internalformat, var_width, var_height);
			SET_LASTCALL("glRenderbufferStorage");
			break;
		}
		case OP_glSampleCoverage: {
			GLclampf var_value = Unpack<GLclampf,uint32_t>(ptr + 8);
			GLboolean var_invert = Unpack<GLboolean,uint8_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 1, ptr + 8 + 4 + 1, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glSampleCoverage: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glSampleCoverage\n", err);
		#endif
			DEBUG("gles2(%p): glSampleCoverage(%f %d )\n", stream, var_value, var_invert);
			this->glSampleCoverage(var_value, var_invert);
			SET_LASTCALL("glSampleCoverage");
			break;
		}
		case OP_glScissor: {
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glScissor: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glScissor\n", err);
		#endif
			DEBUG("gles2(%p): glScissor(%d %d %d %d )\n", stream, var_x, var_y, var_width, var_height);
			this->glScissor(var_x, var_y, var_width, var_height);
			SET_LASTCALL("glScissor");
			break;
		}
		case OP_glShaderBinary: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_shaders __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_shaders(ptr + 8 + 4 + 4, size_shaders);
			GLenum var_binaryformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + size_shaders);
			uint32_t size_binary __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + size_shaders + 4);
			InputBuffer inptr_binary(ptr + 8 + 4 + 4 + size_shaders + 4 + 4, size_binary);
			GLsizei var_length = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + size_shaders + 4 + 4 + size_binary);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_shaders + 4 + 4 + size_binary + 4, ptr + 8 + 4 + 4 + size_shaders + 4 + 4 + size_binary + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glShaderBinary: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glShaderBinary\n", err);
		#endif
			DEBUG("gles2(%p): glShaderBinary(%d %p(%u) 0x%08x %p(%u) %d )\n", stream, var_n, (const GLuint*)(inptr_shaders.get()), size_shaders, var_binaryformat, (const GLvoid*)(inptr_binary.get()), size_binary, var_length);
			this->glShaderBinary(var_n, (const GLuint*)(inptr_shaders.get()), var_binaryformat, (const GLvoid*)(inptr_binary.get()), var_length);
			SET_LASTCALL("glShaderBinary");
			break;
		}
		case OP_glShaderSource: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_string __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_string(ptr + 8 + 4 + 4 + 4, size_string);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_string);
			InputBuffer inptr_length(ptr + 8 + 4 + 4 + 4 + size_string + 4, size_length);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_string + 4 + size_length, ptr + 8 + 4 + 4 + 4 + size_string + 4 + size_length, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glShaderSource: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glShaderSource\n", err);
		#endif
			DEBUG("gles2(%p): glShaderSource(%u %d %p(%u) %p(%u) )\n", stream, var_shader, var_count, (const GLchar* const*)(inptr_string.get()), size_string, (const GLint*)(inptr_length.get()), size_length);
			this->glShaderSource(var_shader, var_count, (const GLchar* const*)(inptr_string.get()), (const GLint*)(inptr_length.get()));
			SET_LASTCALL("glShaderSource");
			break;
		}
		case OP_glStencilFunc: {
			GLenum var_func = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_ref = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLuint var_mask = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glStencilFunc: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glStencilFunc\n", err);
		#endif
			DEBUG("gles2(%p): glStencilFunc(0x%08x %d %u )\n", stream, var_func, var_ref, var_mask);
			this->glStencilFunc(var_func, var_ref, var_mask);
			SET_LASTCALL("glStencilFunc");
			break;
		}
		case OP_glStencilFuncSeparate: {
			GLenum var_face = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_func = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLint var_ref = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_mask = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glStencilFuncSeparate: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glStencilFuncSeparate\n", err);
		#endif
			DEBUG("gles2(%p): glStencilFuncSeparate(0x%08x 0x%08x %d %u )\n", stream, var_face, var_func, var_ref, var_mask);
			this->glStencilFuncSeparate(var_face, var_func, var_ref, var_mask);
			SET_LASTCALL("glStencilFuncSeparate");
			break;
		}
		case OP_glStencilMask: {
			GLuint var_mask = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glStencilMask: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glStencilMask\n", err);
		#endif
			DEBUG("gles2(%p): glStencilMask(%u )\n", stream, var_mask);
			this->glStencilMask(var_mask);
			SET_LASTCALL("glStencilMask");
			break;
		}
		case OP_glStencilMaskSeparate: {
			GLenum var_face = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_mask = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glStencilMaskSeparate: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glStencilMaskSeparate\n", err);
		#endif
			DEBUG("gles2(%p): glStencilMaskSeparate(0x%08x %u )\n", stream, var_face, var_mask);
			this->glStencilMaskSeparate(var_face, var_mask);
			SET_LASTCALL("glStencilMaskSeparate");
			break;
		}
		case OP_glStencilOp: {
			GLenum var_fail = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_zfail = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_zpass = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glStencilOp: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glStencilOp\n", err);
		#endif
			DEBUG("gles2(%p): glStencilOp(0x%08x 0x%08x 0x%08x )\n", stream, var_fail, var_zfail, var_zpass);
			this->glStencilOp(var_fail, var_zfail, var_zpass);
			SET_LASTCALL("glStencilOp");
			break;
		}
		case OP_glStencilOpSeparate: {
			GLenum var_face = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_fail = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_zfail = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLenum var_zpass = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glStencilOpSeparate: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glStencilOpSeparate\n", err);
		#endif
			DEBUG("gles2(%p): glStencilOpSeparate(0x%08x 0x%08x 0x%08x 0x%08x )\n", stream, var_face, var_fail, var_zfail, var_zpass);
			this->glStencilOpSeparate(var_face, var_fail, var_zfail, var_zpass);
			SET_LASTCALL("glStencilOpSeparate");
			break;
		}
		case OP_glTexImage2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_internalformat = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_pixels __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_pixels(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_pixels);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexImage2D: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexImage2D\n", err);
		#endif
			DEBUG("gles2(%p): glTexImage2D(0x%08x %d %d %d %d %d 0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_level, var_internalformat, var_width, var_height, var_border, var_format, var_type, (const GLvoid*)(inptr_pixels.get()), size_pixels);
			this->glTexImage2D(var_target, var_level, var_internalformat, var_width, var_height, var_border, var_format, var_type, size_pixels == 0 ? nullptr : (const GLvoid*)(inptr_pixels.get()));
			SET_LASTCALL("glTexImage2D");
			break;
		}
		case OP_glTexParameterf: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLfloat var_param = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexParameterf: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexParameterf\n", err);
		#endif
			DEBUG("gles2(%p): glTexParameterf(0x%08x 0x%08x %f )\n", stream, var_target, var_pname, var_param);
			this->glTexParameterf(var_target, var_pname, var_param);
			SET_LASTCALL("glTexParameterf");
			break;
		}
		case OP_glTexParameterfv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_params(ptr + 8 + 4 + 4 + 4, size_params);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_params, ptr + 8 + 4 + 4 + 4 + size_params, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexParameterfv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexParameterfv\n", err);
		#endif
			DEBUG("gles2(%p): glTexParameterfv(0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_pname, (const GLfloat*)(inptr_params.get()), size_params);
			this->glTexParameterfv(var_target, var_pname, (const GLfloat*)(inptr_params.get()));
			SET_LASTCALL("glTexParameterfv");
			break;
		}
		case OP_glTexParameteri: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLint var_param = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexParameteri: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexParameteri\n", err);
		#endif
			DEBUG("gles2(%p): glTexParameteri(0x%08x 0x%08x %d )\n", stream, var_target, var_pname, var_param);
			this->glTexParameteri(var_target, var_pname, var_param);
			SET_LASTCALL("glTexParameteri");
			break;
		}
		case OP_glTexParameteriv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_params(ptr + 8 + 4 + 4 + 4, size_params);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_params, ptr + 8 + 4 + 4 + 4 + size_params, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexParameteriv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexParameteriv\n", err);
		#endif
			DEBUG("gles2(%p): glTexParameteriv(0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_pname, (const GLint*)(inptr_params.get()), size_params);
			this->glTexParameteriv(var_target, var_pname, (const GLint*)(inptr_params.get()));
			SET_LASTCALL("glTexParameteriv");
			break;
		}
		case OP_glTexSubImage2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_pixels __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_pixels(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_pixels);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexSubImage2D: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexSubImage2D\n", err);
		#endif
			DEBUG("gles2(%p): glTexSubImage2D(0x%08x %d %d %d %d %d 0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_level, var_xoffset, var_yoffset, var_width, var_height, var_format, var_type, (const GLvoid*)(inptr_pixels.get()), size_pixels);
			this->glTexSubImage2D(var_target, var_level, var_xoffset, var_yoffset, var_width, var_height, var_format, var_type, size_pixels == 0 ? nullptr : (const GLvoid*)(inptr_pixels.get()));
			SET_LASTCALL("glTexSubImage2D");
			break;
		}
		case OP_glUniform1f: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform1f: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform1f\n", err);
		#endif
			DEBUG("gles2(%p): glUniform1f(%d %f )\n", stream, var_location, var_x);
			this->glUniform1f(var_location, var_x);
			SET_LASTCALL("glUniform1f");
			break;
		}
		case OP_glUniform1fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform1fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform1fv\n", err);
		#endif
			DEBUG("gles2(%p): glUniform1fv(%d %d %p(%u) )\n", stream, var_location, var_count, (const GLfloat*)(inptr_v.get()), size_v);
			this->glUniform1fv(var_location, var_count, (const GLfloat*)(inptr_v.get()));
			SET_LASTCALL("glUniform1fv");
			break;
		}
		case OP_glUniform1i: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform1i: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform1i\n", err);
		#endif
			DEBUG("gles2(%p): glUniform1i(%d %d )\n", stream, var_location, var_x);
			this->glUniform1i(var_location, var_x);
			SET_LASTCALL("glUniform1i");
			break;
		}
		case OP_glUniform1iv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform1iv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform1iv\n", err);
		#endif
			DEBUG("gles2(%p): glUniform1iv(%d %d %p(%u) )\n", stream, var_location, var_count, (const GLint*)(inptr_v.get()), size_v);
			this->glUniform1iv(var_location, var_count, (const GLint*)(inptr_v.get()));
			SET_LASTCALL("glUniform1iv");
			break;
		}
		case OP_glUniform2f: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			GLfloat var_y = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform2f: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform2f\n", err);
		#endif
			DEBUG("gles2(%p): glUniform2f(%d %f %f )\n", stream, var_location, var_x, var_y);
			this->glUniform2f(var_location, var_x, var_y);
			SET_LASTCALL("glUniform2f");
			break;
		}
		case OP_glUniform2fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform2fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform2fv\n", err);
		#endif
			DEBUG("gles2(%p): glUniform2fv(%d %d %p(%u) )\n", stream, var_location, var_count, (const GLfloat*)(inptr_v.get()), size_v);
			this->glUniform2fv(var_location, var_count, (const GLfloat*)(inptr_v.get()));
			SET_LASTCALL("glUniform2fv");
			break;
		}
		case OP_glUniform2i: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform2i: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform2i\n", err);
		#endif
			DEBUG("gles2(%p): glUniform2i(%d %d %d )\n", stream, var_location, var_x, var_y);
			this->glUniform2i(var_location, var_x, var_y);
			SET_LASTCALL("glUniform2i");
			break;
		}
		case OP_glUniform2iv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform2iv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform2iv\n", err);
		#endif
			DEBUG("gles2(%p): glUniform2iv(%d %d %p(%u) )\n", stream, var_location, var_count, (const GLint*)(inptr_v.get()), size_v);
			this->glUniform2iv(var_location, var_count, (const GLint*)(inptr_v.get()));
			SET_LASTCALL("glUniform2iv");
			break;
		}
		case OP_glUniform3f: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			GLfloat var_y = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			GLfloat var_z = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform3f: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform3f\n", err);
		#endif
			DEBUG("gles2(%p): glUniform3f(%d %f %f %f )\n", stream, var_location, var_x, var_y, var_z);
			this->glUniform3f(var_location, var_x, var_y, var_z);
			SET_LASTCALL("glUniform3f");
			break;
		}
		case OP_glUniform3fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform3fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform3fv\n", err);
		#endif
			DEBUG("gles2(%p): glUniform3fv(%d %d %p(%u) )\n", stream, var_location, var_count, (const GLfloat*)(inptr_v.get()), size_v);
			this->glUniform3fv(var_location, var_count, (const GLfloat*)(inptr_v.get()));
			SET_LASTCALL("glUniform3fv");
			break;
		}
		case OP_glUniform3i: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_z = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform3i: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform3i\n", err);
		#endif
			DEBUG("gles2(%p): glUniform3i(%d %d %d %d )\n", stream, var_location, var_x, var_y, var_z);
			this->glUniform3i(var_location, var_x, var_y, var_z);
			SET_LASTCALL("glUniform3i");
			break;
		}
		case OP_glUniform3iv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform3iv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform3iv\n", err);
		#endif
			DEBUG("gles2(%p): glUniform3iv(%d %d %p(%u) )\n", stream, var_location, var_count, (const GLint*)(inptr_v.get()), size_v);
			this->glUniform3iv(var_location, var_count, (const GLint*)(inptr_v.get()));
			SET_LASTCALL("glUniform3iv");
			break;
		}
		case OP_glUniform4f: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			GLfloat var_y = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			GLfloat var_z = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLfloat var_w = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform4f: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform4f\n", err);
		#endif
			DEBUG("gles2(%p): glUniform4f(%d %f %f %f %f )\n", stream, var_location, var_x, var_y, var_z, var_w);
			this->glUniform4f(var_location, var_x, var_y, var_z, var_w);
			SET_LASTCALL("glUniform4f");
			break;
		}
		case OP_glUniform4fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform4fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform4fv\n", err);
		#endif
			DEBUG("gles2(%p): glUniform4fv(%d %d %p(%u) )\n", stream, var_location, var_count, (const GLfloat*)(inptr_v.get()), size_v);
			this->glUniform4fv(var_location, var_count, (const GLfloat*)(inptr_v.get()));
			SET_LASTCALL("glUniform4fv");
			break;
		}
		case OP_glUniform4i: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_z = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_w = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform4i: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform4i\n", err);
		#endif
			DEBUG("gles2(%p): glUniform4i(%d %d %d %d %d )\n", stream, var_location, var_x, var_y, var_z, var_w);
			this->glUniform4i(var_location, var_x, var_y, var_z, var_w);
			SET_LASTCALL("glUniform4i");
			break;
		}
		case OP_glUniform4iv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform4iv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform4iv\n", err);
		#endif
			DEBUG("gles2(%p): glUniform4iv(%d %d %p(%u) )\n", stream, var_location, var_count, (const GLint*)(inptr_v.get()), size_v);
			this->glUniform4iv(var_location, var_count, (const GLint*)(inptr_v.get()));
			SET_LASTCALL("glUniform4iv");
			break;
		}
		case OP_glUniformMatrix2fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniformMatrix2fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniformMatrix2fv\n", err);
		#endif
			DEBUG("gles2(%p): glUniformMatrix2fv(%d %d %d %p(%u) )\n", stream, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glUniformMatrix2fv(var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glUniformMatrix2fv");
			break;
		}
		case OP_glUniformMatrix3fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniformMatrix3fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniformMatrix3fv\n", err);
		#endif
			DEBUG("gles2(%p): glUniformMatrix3fv(%d %d %d %p(%u) )\n", stream, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glUniformMatrix3fv(var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glUniformMatrix3fv");
			break;
		}
		case OP_glUniformMatrix4fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniformMatrix4fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniformMatrix4fv\n", err);
		#endif
			DEBUG("gles2(%p): glUniformMatrix4fv(%d %d %d %p(%u) )\n", stream, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glUniformMatrix4fv(var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glUniformMatrix4fv");
			break;
		}
		case OP_glUseProgram: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUseProgram: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUseProgram\n", err);
		#endif
			DEBUG("gles2(%p): glUseProgram(%u )\n", stream, var_program);
			this->glUseProgram(var_program);
			SET_LASTCALL("glUseProgram");
			break;
		}
		case OP_glValidateProgram: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glValidateProgram: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glValidateProgram\n", err);
		#endif
			DEBUG("gles2(%p): glValidateProgram(%u )\n", stream, var_program);
			this->glValidateProgram(var_program);
			SET_LASTCALL("glValidateProgram");
			break;
		}
		case OP_glVertexAttrib1f: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttrib1f: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttrib1f\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttrib1f(%u %f )\n", stream, var_indx, var_x);
			this->glVertexAttrib1f(var_indx, var_x);
			SET_LASTCALL("glVertexAttrib1f");
			break;
		}
		case OP_glVertexAttrib1fv: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_values __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_values(ptr + 8 + 4 + 4, size_values);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_values, ptr + 8 + 4 + 4 + size_values, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttrib1fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttrib1fv\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttrib1fv(%u %p(%u) )\n", stream, var_indx, (const GLfloat*)(inptr_values.get()), size_values);
			this->glVertexAttrib1fv(var_indx, (const GLfloat*)(inptr_values.get()));
			SET_LASTCALL("glVertexAttrib1fv");
			break;
		}
		case OP_glVertexAttrib2f: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			GLfloat var_y = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttrib2f: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttrib2f\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttrib2f(%u %f %f )\n", stream, var_indx, var_x, var_y);
			this->glVertexAttrib2f(var_indx, var_x, var_y);
			SET_LASTCALL("glVertexAttrib2f");
			break;
		}
		case OP_glVertexAttrib2fv: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_values __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_values(ptr + 8 + 4 + 4, size_values);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_values, ptr + 8 + 4 + 4 + size_values, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttrib2fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttrib2fv\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttrib2fv(%u %p(%u) )\n", stream, var_indx, (const GLfloat*)(inptr_values.get()), size_values);
			this->glVertexAttrib2fv(var_indx, (const GLfloat*)(inptr_values.get()));
			SET_LASTCALL("glVertexAttrib2fv");
			break;
		}
		case OP_glVertexAttrib3f: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			GLfloat var_y = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			GLfloat var_z = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttrib3f: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttrib3f\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttrib3f(%u %f %f %f )\n", stream, var_indx, var_x, var_y, var_z);
			this->glVertexAttrib3f(var_indx, var_x, var_y, var_z);
			SET_LASTCALL("glVertexAttrib3f");
			break;
		}
		case OP_glVertexAttrib3fv: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_values __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_values(ptr + 8 + 4 + 4, size_values);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_values, ptr + 8 + 4 + 4 + size_values, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttrib3fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttrib3fv\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttrib3fv(%u %p(%u) )\n", stream, var_indx, (const GLfloat*)(inptr_values.get()), size_values);
			this->glVertexAttrib3fv(var_indx, (const GLfloat*)(inptr_values.get()));
			SET_LASTCALL("glVertexAttrib3fv");
			break;
		}
		case OP_glVertexAttrib4f: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			GLfloat var_y = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			GLfloat var_z = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLfloat var_w = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttrib4f: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttrib4f\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttrib4f(%u %f %f %f %f )\n", stream, var_indx, var_x, var_y, var_z, var_w);
			this->glVertexAttrib4f(var_indx, var_x, var_y, var_z, var_w);
			SET_LASTCALL("glVertexAttrib4f");
			break;
		}
		case OP_glVertexAttrib4fv: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_values __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_values(ptr + 8 + 4 + 4, size_values);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_values, ptr + 8 + 4 + 4 + size_values, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttrib4fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttrib4fv\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttrib4fv(%u %p(%u) )\n", stream, var_indx, (const GLfloat*)(inptr_values.get()), size_values);
			this->glVertexAttrib4fv(var_indx, (const GLfloat*)(inptr_values.get()));
			SET_LASTCALL("glVertexAttrib4fv");
			break;
		}
		case OP_glVertexAttribPointer: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_size = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_normalized = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_stride = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			uint32_t size_ptr __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1 + 4);
			InputBuffer inptr_ptr(ptr + 8 + 4 + 4 + 4 + 1 + 4 + 4, size_ptr);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 1 + 4 + 4 + size_ptr, ptr + 8 + 4 + 4 + 4 + 1 + 4 + 4 + size_ptr, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttribPointer: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttribPointer\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttribPointer(%u %d 0x%08x %d %d %p(%u) )\n", stream, var_indx, var_size, var_type, var_normalized, var_stride, (const GLvoid*)(inptr_ptr.get()), size_ptr);
			this->glVertexAttribPointer(var_indx, var_size, var_type, var_normalized, var_stride, (const GLvoid*)(inptr_ptr.get()));
			SET_LASTCALL("glVertexAttribPointer");
			break;
		}
		case OP_glViewport: {
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glViewport: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glViewport\n", err);
		#endif
			DEBUG("gles2(%p): glViewport(%d %d %d %d )\n", stream, var_x, var_y, var_width, var_height);
			this->glViewport(var_x, var_y, var_width, var_height);
			SET_LASTCALL("glViewport");
			break;
		}
		case OP_glEGLImageTargetTexture2DOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLeglImageOES var_image = Unpack<GLeglImageOES,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glEGLImageTargetTexture2DOES: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glEGLImageTargetTexture2DOES\n", err);
		#endif
			DEBUG("gles2(%p): glEGLImageTargetTexture2DOES(0x%08x %p )\n", stream, var_target, var_image);
			this->glEGLImageTargetTexture2DOES(var_target, var_image);
			SET_LASTCALL("glEGLImageTargetTexture2DOES");
			break;
		}
		case OP_glEGLImageTargetRenderbufferStorageOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLeglImageOES var_image = Unpack<GLeglImageOES,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glEGLImageTargetRenderbufferStorageOES: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glEGLImageTargetRenderbufferStorageOES\n", err);
		#endif
			DEBUG("gles2(%p): glEGLImageTargetRenderbufferStorageOES(0x%08x %p )\n", stream, var_target, var_image);
			this->glEGLImageTargetRenderbufferStorageOES(var_target, var_image);
			SET_LASTCALL("glEGLImageTargetRenderbufferStorageOES");
			break;
		}
		case OP_glGetProgramBinaryOES: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_length(ptr + 8 + 4 + 4 + 4, size_length);
			uint32_t size_binaryFormat __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_length);
			InputBuffer inptr_binaryFormat(ptr + 8 + 4 + 4 + 4 + size_length + 4, size_binaryFormat);
			uint32_t size_binary __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_length + 4 + size_binaryFormat);
			InputBuffer inptr_binary(ptr + 8 + 4 + 4 + 4 + size_length + 4 + size_binaryFormat + 4, size_binary);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_length + 4 + size_binaryFormat + 4 + size_binary, ptr + 8 + 4 + 4 + 4 + size_length + 4 + size_binaryFormat + 4 + size_binary, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetProgramBinaryOES: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetProgramBinaryOES\n", err);
		#endif
			DEBUG("gles2(%p): glGetProgramBinaryOES(%u %d %p(%u) %p(%u) %p(%u) )\n", stream, var_program, var_bufSize, (GLsizei*)(inptr_length.get()), size_length, (GLenum*)(inptr_binaryFormat.get()), size_binaryFormat, (GLvoid*)(inptr_binary.get()), size_binary);
			this->glGetProgramBinaryOES(var_program, var_bufSize, (GLsizei*)(inptr_length.get()), (GLenum*)(inptr_binaryFormat.get()), (GLvoid*)(inptr_binary.get()));
			SET_LASTCALL("glGetProgramBinaryOES");
			break;
		}
		case OP_glProgramBinaryOES: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_binaryFormat = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_binary __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_binary(ptr + 8 + 4 + 4 + 4, size_binary);
			GLint var_length = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_binary);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_binary + 4, ptr + 8 + 4 + 4 + 4 + size_binary + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramBinaryOES: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramBinaryOES\n", err);
		#endif
			DEBUG("gles2(%p): glProgramBinaryOES(%u 0x%08x %p(%u) %d )\n", stream, var_program, var_binaryFormat, (const GLvoid*)(inptr_binary.get()), size_binary, var_length);
			this->glProgramBinaryOES(var_program, var_binaryFormat, (const GLvoid*)(inptr_binary.get()), var_length);
			SET_LASTCALL("glProgramBinaryOES");
			break;
		}
		case OP_glMapBufferOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_access = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glMapBufferOES: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glMapBufferOES\n", err);
		#endif
			DEBUG("gles2(%p): glMapBufferOES(0x%08x 0x%08x )\n", stream, var_target, var_access);
			this->glMapBufferOES(var_target, var_access);
			SET_LASTCALL("glMapBufferOES");
			break;
		}
		case OP_glUnmapBufferOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUnmapBufferOES: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUnmapBufferOES\n", err);
		#endif
			DEBUG("gles2(%p): glUnmapBufferOES(0x%08x )\n", stream, var_target);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glUnmapBufferOES(var_target);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glUnmapBufferOES");
			break;
		}
		case OP_glTexImage3DOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_pixels __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_pixels(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_pixels);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexImage3DOES: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexImage3DOES\n", err);
		#endif
			DEBUG("gles2(%p): glTexImage3DOES(0x%08x %d 0x%08x %d %d %d %d 0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_level, var_internalformat, var_width, var_height, var_depth, var_border, var_format, var_type, (const GLvoid*)(inptr_pixels.get()), size_pixels);
			this->glTexImage3DOES(var_target, var_level, var_internalformat, var_width, var_height, var_depth, var_border, var_format, var_type, size_pixels == 0 ? nullptr : (const GLvoid*)(inptr_pixels.get()));
			SET_LASTCALL("glTexImage3DOES");
			break;
		}
		case OP_glTexSubImage3DOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_pixels __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_pixels(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_pixels);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexSubImage3DOES: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexSubImage3DOES\n", err);
		#endif
			DEBUG("gles2(%p): glTexSubImage3DOES(0x%08x %d %d %d %d %d %d %d 0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_type, (const GLvoid*)(inptr_pixels.get()), size_pixels);
			this->glTexSubImage3DOES(var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_type, size_pixels == 0 ? nullptr : (const GLvoid*)(inptr_pixels.get()));
			SET_LASTCALL("glTexSubImage3DOES");
			break;
		}
		case OP_glCopyTexSubImage3DOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCopyTexSubImage3DOES: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCopyTexSubImage3DOES\n", err);
		#endif
			DEBUG("gles2(%p): glCopyTexSubImage3DOES(0x%08x %d %d %d %d %d %d %d %d )\n", stream, var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_x, var_y, var_width, var_height);
			this->glCopyTexSubImage3DOES(var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_x, var_y, var_width, var_height);
			SET_LASTCALL("glCopyTexSubImage3DOES");
			break;
		}
		case OP_glCompressedTexImage3DOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_imageSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCompressedTexImage3DOES: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCompressedTexImage3DOES\n", err);
		#endif
			DEBUG("gles2(%p): glCompressedTexImage3DOES(0x%08x %d 0x%08x %d %d %d %d %d %p(%u) )\n", stream, var_target, var_level, var_internalformat, var_width, var_height, var_depth, var_border, var_imageSize, (const GLvoid*)(inptr_data.get()), size_data);
			this->glCompressedTexImage3DOES(var_target, var_level, var_internalformat, var_width, var_height, var_depth, var_border, var_imageSize, size_data == 0 ? nullptr : (const GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glCompressedTexImage3DOES");
			break;
		}
		case OP_glCompressedTexSubImage3DOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_imageSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCompressedTexSubImage3DOES: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCompressedTexSubImage3DOES\n", err);
		#endif
			DEBUG("gles2(%p): glCompressedTexSubImage3DOES(0x%08x %d %d %d %d %d %d %d 0x%08x %d %p(%u) )\n", stream, var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_imageSize, (const GLvoid*)(inptr_data.get()), size_data);
			this->glCompressedTexSubImage3DOES(var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_imageSize, size_data == 0 ? nullptr : (const GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glCompressedTexSubImage3DOES");
			break;
		}
		case OP_glFramebufferTexture3DOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_attachment = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_textarget = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_texture = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFramebufferTexture3DOES: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFramebufferTexture3DOES\n", err);
		#endif
			DEBUG("gles2(%p): glFramebufferTexture3DOES(0x%08x 0x%08x 0x%08x %u %d %d )\n", stream, var_target, var_attachment, var_textarget, var_texture, var_level, var_zoffset);
			this->glFramebufferTexture3DOES(var_target, var_attachment, var_textarget, var_texture, var_level, var_zoffset);
			SET_LASTCALL("glFramebufferTexture3DOES");
			break;
		}
		case OP_glBindVertexArrayOES: {
			GLuint var_array = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBindVertexArrayOES: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBindVertexArrayOES\n", err);
		#endif
			DEBUG("gles2(%p): glBindVertexArrayOES(%u )\n", stream, var_array);
			this->glBindVertexArrayOES(var_array);
			SET_LASTCALL("glBindVertexArrayOES");
			break;
		}
		case OP_glDeleteVertexArraysOES: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_arrays __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_arrays(ptr + 8 + 4 + 4, size_arrays);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_arrays, ptr + 8 + 4 + 4 + size_arrays, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteVertexArraysOES: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteVertexArraysOES\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteVertexArraysOES(%d %p(%u) )\n", stream, var_n, (const GLuint*)(inptr_arrays.get()), size_arrays);
			this->glDeleteVertexArraysOES(var_n, (const GLuint*)(inptr_arrays.get()));
			SET_LASTCALL("glDeleteVertexArraysOES");
			break;
		}
		case OP_glGenVertexArraysOES: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_arrays __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGenVertexArraysOES: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_arrays;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_arrays(&tmpBuf[0], size_arrays);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGenVertexArraysOES\n", err);
		#endif
			DEBUG("gles2(%p): glGenVertexArraysOES(%d %p(%u) )\n", stream, var_n, (GLuint*)(outptr_arrays.get()), size_arrays);
			this->glGenVertexArraysOES(var_n, (GLuint*)(outptr_arrays.get()));
			outptr_arrays.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenVertexArraysOES");
			break;
		}
		case OP_glIsVertexArrayOES: {
			GLuint var_array = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsVertexArrayOES: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsVertexArrayOES\n", err);
		#endif
			DEBUG("gles2(%p): glIsVertexArrayOES(%u )\n", stream, var_array);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsVertexArrayOES(var_array);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsVertexArrayOES");
			break;
		}
		case OP_glDiscardFramebufferEXT: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_numAttachments = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_attachments __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_attachments(ptr + 8 + 4 + 4 + 4, size_attachments);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_attachments, ptr + 8 + 4 + 4 + 4 + size_attachments, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDiscardFramebufferEXT: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDiscardFramebufferEXT\n", err);
		#endif
			DEBUG("gles2(%p): glDiscardFramebufferEXT(0x%08x %d %p(%u) )\n", stream, var_target, var_numAttachments, (const GLenum*)(inptr_attachments.get()), size_attachments);
			this->glDiscardFramebufferEXT(var_target, var_numAttachments, (const GLenum*)(inptr_attachments.get()));
			SET_LASTCALL("glDiscardFramebufferEXT");
			break;
		}
		case OP_glMultiDrawArraysEXT: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_first __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_first(ptr + 8 + 4 + 4, size_first);
			uint32_t size_count __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + size_first);
			InputBuffer inptr_count(ptr + 8 + 4 + 4 + size_first + 4, size_count);
			GLsizei var_primcount = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + size_first + 4 + size_count);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_first + 4 + size_count + 4, ptr + 8 + 4 + 4 + size_first + 4 + size_count + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glMultiDrawArraysEXT: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glMultiDrawArraysEXT\n", err);
		#endif
			DEBUG("gles2(%p): glMultiDrawArraysEXT(0x%08x %p(%u) %p(%u) %d )\n", stream, var_mode, (const GLint*)(inptr_first.get()), size_first, (const GLsizei*)(inptr_count.get()), size_count, var_primcount);
			this->glMultiDrawArraysEXT(var_mode, (const GLint*)(inptr_first.get()), (const GLsizei*)(inptr_count.get()), var_primcount);
			SET_LASTCALL("glMultiDrawArraysEXT");
			break;
		}
		case OP_glMultiDrawElementsEXT: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_count __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_count(ptr + 8 + 4 + 4, size_count);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + size_count);
			uint32_t size_indices __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + size_count + 4);
			InputBuffer inptr_indices(ptr + 8 + 4 + 4 + size_count + 4 + 4, size_indices);
			GLsizei var_primcount = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + size_count + 4 + 4 + size_indices);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_count + 4 + 4 + size_indices + 4, ptr + 8 + 4 + 4 + size_count + 4 + 4 + size_indices + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glMultiDrawElementsEXT: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glMultiDrawElementsEXT\n", err);
		#endif
			DEBUG("gles2(%p): glMultiDrawElementsEXT(0x%08x %p(%u) 0x%08x %p(%u) %d )\n", stream, var_mode, (const GLsizei*)(inptr_count.get()), size_count, var_type, (const GLvoid* const*)(inptr_indices.get()), size_indices, var_primcount);
			this->glMultiDrawElementsEXT(var_mode, (const GLsizei*)(inptr_count.get()), var_type, (const GLvoid* const*)(inptr_indices.get()), var_primcount);
			SET_LASTCALL("glMultiDrawElementsEXT");
			break;
		}
		case OP_glGetPerfMonitorGroupsAMD: {
			uint32_t size_numGroups __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_numGroups(ptr + 8 + 4, size_numGroups);
			GLsizei var_groupsSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + size_numGroups);
			uint32_t size_groups __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_numGroups + 4);
			InputBuffer inptr_groups(ptr + 8 + 4 + size_numGroups + 4 + 4, size_groups);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + size_numGroups + 4 + 4 + size_groups, ptr + 8 + 4 + size_numGroups + 4 + 4 + size_groups, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetPerfMonitorGroupsAMD: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetPerfMonitorGroupsAMD\n", err);
		#endif
			DEBUG("gles2(%p): glGetPerfMonitorGroupsAMD(%p(%u) %d %p(%u) )\n", stream, (GLint*)(inptr_numGroups.get()), size_numGroups, var_groupsSize, (GLuint*)(inptr_groups.get()), size_groups);
			this->glGetPerfMonitorGroupsAMD((GLint*)(inptr_numGroups.get()), var_groupsSize, (GLuint*)(inptr_groups.get()));
			SET_LASTCALL("glGetPerfMonitorGroupsAMD");
			break;
		}
		case OP_glGetPerfMonitorCountersAMD: {
			GLuint var_group = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_numCounters __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_numCounters(ptr + 8 + 4 + 4, size_numCounters);
			uint32_t size_maxActiveCounters __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + size_numCounters);
			InputBuffer inptr_maxActiveCounters(ptr + 8 + 4 + 4 + size_numCounters + 4, size_maxActiveCounters);
			GLsizei var_counterSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + size_numCounters + 4 + size_maxActiveCounters);
			uint32_t size_counters __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + size_numCounters + 4 + size_maxActiveCounters + 4);
			InputBuffer inptr_counters(ptr + 8 + 4 + 4 + size_numCounters + 4 + size_maxActiveCounters + 4 + 4, size_counters);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_numCounters + 4 + size_maxActiveCounters + 4 + 4 + size_counters, ptr + 8 + 4 + 4 + size_numCounters + 4 + size_maxActiveCounters + 4 + 4 + size_counters, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetPerfMonitorCountersAMD: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetPerfMonitorCountersAMD\n", err);
		#endif
			DEBUG("gles2(%p): glGetPerfMonitorCountersAMD(%u %p(%u) %p(%u) %d %p(%u) )\n", stream, var_group, (GLint*)(inptr_numCounters.get()), size_numCounters, (GLint*)(inptr_maxActiveCounters.get()), size_maxActiveCounters, var_counterSize, (GLuint*)(inptr_counters.get()), size_counters);
			this->glGetPerfMonitorCountersAMD(var_group, (GLint*)(inptr_numCounters.get()), (GLint*)(inptr_maxActiveCounters.get()), var_counterSize, (GLuint*)(inptr_counters.get()));
			SET_LASTCALL("glGetPerfMonitorCountersAMD");
			break;
		}
		case OP_glGetPerfMonitorGroupStringAMD: {
			GLuint var_group = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_length(ptr + 8 + 4 + 4 + 4, size_length);
			uint32_t size_groupString __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_length);
			InputBuffer inptr_groupString(ptr + 8 + 4 + 4 + 4 + size_length + 4, size_groupString);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_length + 4 + size_groupString, ptr + 8 + 4 + 4 + 4 + size_length + 4 + size_groupString, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetPerfMonitorGroupStringAMD: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetPerfMonitorGroupStringAMD\n", err);
		#endif
			DEBUG("gles2(%p): glGetPerfMonitorGroupStringAMD(%u %d %p(%u) %p(%u) )\n", stream, var_group, var_bufSize, (GLsizei*)(inptr_length.get()), size_length, (GLchar*)(inptr_groupString.get()), size_groupString);
			this->glGetPerfMonitorGroupStringAMD(var_group, var_bufSize, (GLsizei*)(inptr_length.get()), (GLchar*)(inptr_groupString.get()));
			SET_LASTCALL("glGetPerfMonitorGroupStringAMD");
			break;
		}
		case OP_glGetPerfMonitorCounterStringAMD: {
			GLuint var_group = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_counter = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_length(ptr + 8 + 4 + 4 + 4 + 4, size_length);
			uint32_t size_counterString __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + size_length);
			InputBuffer inptr_counterString(ptr + 8 + 4 + 4 + 4 + 4 + size_length + 4, size_counterString);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_length + 4 + size_counterString, ptr + 8 + 4 + 4 + 4 + 4 + size_length + 4 + size_counterString, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetPerfMonitorCounterStringAMD: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetPerfMonitorCounterStringAMD\n", err);
		#endif
			DEBUG("gles2(%p): glGetPerfMonitorCounterStringAMD(%u %u %d %p(%u) %p(%u) )\n", stream, var_group, var_counter, var_bufSize, (GLsizei*)(inptr_length.get()), size_length, (GLchar*)(inptr_counterString.get()), size_counterString);
			this->glGetPerfMonitorCounterStringAMD(var_group, var_counter, var_bufSize, (GLsizei*)(inptr_length.get()), (GLchar*)(inptr_counterString.get()));
			SET_LASTCALL("glGetPerfMonitorCounterStringAMD");
			break;
		}
		case OP_glGetPerfMonitorCounterInfoAMD: {
			GLuint var_group = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_counter = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetPerfMonitorCounterInfoAMD: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetPerfMonitorCounterInfoAMD\n", err);
		#endif
			DEBUG("gles2(%p): glGetPerfMonitorCounterInfoAMD(%u %u 0x%08x %p(%u) )\n", stream, var_group, var_counter, var_pname, (GLvoid*)(inptr_data.get()), size_data);
			this->glGetPerfMonitorCounterInfoAMD(var_group, var_counter, var_pname, (GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glGetPerfMonitorCounterInfoAMD");
			break;
		}
		case OP_glGenPerfMonitorsAMD: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_monitors __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_monitors(ptr + 8 + 4 + 4, size_monitors);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_monitors, ptr + 8 + 4 + 4 + size_monitors, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGenPerfMonitorsAMD: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGenPerfMonitorsAMD\n", err);
		#endif
			DEBUG("gles2(%p): glGenPerfMonitorsAMD(%d %p(%u) )\n", stream, var_n, (GLuint*)(inptr_monitors.get()), size_monitors);
			this->glGenPerfMonitorsAMD(var_n, (GLuint*)(inptr_monitors.get()));
			SET_LASTCALL("glGenPerfMonitorsAMD");
			break;
		}
		case OP_glDeletePerfMonitorsAMD: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_monitors __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_monitors(ptr + 8 + 4 + 4, size_monitors);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_monitors, ptr + 8 + 4 + 4 + size_monitors, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeletePerfMonitorsAMD: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeletePerfMonitorsAMD\n", err);
		#endif
			DEBUG("gles2(%p): glDeletePerfMonitorsAMD(%d %p(%u) )\n", stream, var_n, (GLuint*)(inptr_monitors.get()), size_monitors);
			this->glDeletePerfMonitorsAMD(var_n, (GLuint*)(inptr_monitors.get()));
			SET_LASTCALL("glDeletePerfMonitorsAMD");
			break;
		}
		case OP_glSelectPerfMonitorCountersAMD: {
			GLuint var_monitor = Unpack<GLuint,uint32_t>(ptr + 8);
			GLboolean var_enable = Unpack<GLboolean,uint8_t>(ptr + 8 + 4);
			GLuint var_group = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 1);
			GLint var_numCounters = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 1 + 4);
			uint32_t size_countersList __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 1 + 4 + 4);
			InputBuffer inptr_countersList(ptr + 8 + 4 + 1 + 4 + 4 + 4, size_countersList);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 1 + 4 + 4 + 4 + size_countersList, ptr + 8 + 4 + 1 + 4 + 4 + 4 + size_countersList, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glSelectPerfMonitorCountersAMD: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glSelectPerfMonitorCountersAMD\n", err);
		#endif
			DEBUG("gles2(%p): glSelectPerfMonitorCountersAMD(%u %d %u %d %p(%u) )\n", stream, var_monitor, var_enable, var_group, var_numCounters, (GLuint*)(inptr_countersList.get()), size_countersList);
			this->glSelectPerfMonitorCountersAMD(var_monitor, var_enable, var_group, var_numCounters, (GLuint*)(inptr_countersList.get()));
			SET_LASTCALL("glSelectPerfMonitorCountersAMD");
			break;
		}
		case OP_glBeginPerfMonitorAMD: {
			GLuint var_monitor = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBeginPerfMonitorAMD: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBeginPerfMonitorAMD\n", err);
		#endif
			DEBUG("gles2(%p): glBeginPerfMonitorAMD(%u )\n", stream, var_monitor);
			this->glBeginPerfMonitorAMD(var_monitor);
			SET_LASTCALL("glBeginPerfMonitorAMD");
			break;
		}
		case OP_glEndPerfMonitorAMD: {
			GLuint var_monitor = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glEndPerfMonitorAMD: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glEndPerfMonitorAMD\n", err);
		#endif
			DEBUG("gles2(%p): glEndPerfMonitorAMD(%u )\n", stream, var_monitor);
			this->glEndPerfMonitorAMD(var_monitor);
			SET_LASTCALL("glEndPerfMonitorAMD");
			break;
		}
		case OP_glGetPerfMonitorCounterDataAMD: {
			GLuint var_monitor = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLsizei var_dataSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4, size_data);
			uint32_t size_bytesWritten __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + size_data);
			InputBuffer inptr_bytesWritten(ptr + 8 + 4 + 4 + 4 + 4 + size_data + 4, size_bytesWritten);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_data + 4 + size_bytesWritten, ptr + 8 + 4 + 4 + 4 + 4 + size_data + 4 + size_bytesWritten, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetPerfMonitorCounterDataAMD: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetPerfMonitorCounterDataAMD\n", err);
		#endif
			DEBUG("gles2(%p): glGetPerfMonitorCounterDataAMD(%u 0x%08x %d %p(%u) %p(%u) )\n", stream, var_monitor, var_pname, var_dataSize, (GLuint*)(inptr_data.get()), size_data, (GLint*)(inptr_bytesWritten.get()), size_bytesWritten);
			this->glGetPerfMonitorCounterDataAMD(var_monitor, var_pname, var_dataSize, (GLuint*)(inptr_data.get()), (GLint*)(inptr_bytesWritten.get()));
			SET_LASTCALL("glGetPerfMonitorCounterDataAMD");
			break;
		}
		case OP_glRenderbufferStorageMultisampleIMG: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_samples = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glRenderbufferStorageMultisampleIMG: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glRenderbufferStorageMultisampleIMG\n", err);
		#endif
			DEBUG("gles2(%p): glRenderbufferStorageMultisampleIMG(0x%08x %d 0x%08x %d %d )\n", stream, var_target, var_samples, var_internalformat, var_width, var_height);
			this->glRenderbufferStorageMultisampleIMG(var_target, var_samples, var_internalformat, var_width, var_height);
			SET_LASTCALL("glRenderbufferStorageMultisampleIMG");
			break;
		}
		case OP_glFramebufferTexture2DMultisampleIMG: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_attachment = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_textarget = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_texture = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_samples = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFramebufferTexture2DMultisampleIMG: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFramebufferTexture2DMultisampleIMG\n", err);
		#endif
			DEBUG("gles2(%p): glFramebufferTexture2DMultisampleIMG(0x%08x 0x%08x 0x%08x %u %d %d )\n", stream, var_target, var_attachment, var_textarget, var_texture, var_level, var_samples);
			this->glFramebufferTexture2DMultisampleIMG(var_target, var_attachment, var_textarget, var_texture, var_level, var_samples);
			SET_LASTCALL("glFramebufferTexture2DMultisampleIMG");
			break;
		}
		case OP_glDeleteFencesNV: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_fences __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_fences(ptr + 8 + 4 + 4, size_fences);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_fences, ptr + 8 + 4 + 4 + size_fences, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteFencesNV: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteFencesNV\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteFencesNV(%d %p(%u) )\n", stream, var_n, (const GLuint*)(inptr_fences.get()), size_fences);
			this->glDeleteFencesNV(var_n, (const GLuint*)(inptr_fences.get()));
			SET_LASTCALL("glDeleteFencesNV");
			break;
		}
		case OP_glGenFencesNV: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_fences __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_fences(ptr + 8 + 4 + 4, size_fences);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_fences, ptr + 8 + 4 + 4 + size_fences, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGenFencesNV: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGenFencesNV\n", err);
		#endif
			DEBUG("gles2(%p): glGenFencesNV(%d %p(%u) )\n", stream, var_n, (GLuint*)(inptr_fences.get()), size_fences);
			this->glGenFencesNV(var_n, (GLuint*)(inptr_fences.get()));
			SET_LASTCALL("glGenFencesNV");
			break;
		}
		case OP_glIsFenceNV: {
			GLuint var_fence = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsFenceNV: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsFenceNV\n", err);
		#endif
			DEBUG("gles2(%p): glIsFenceNV(%u )\n", stream, var_fence);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsFenceNV(var_fence);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsFenceNV");
			break;
		}
		case OP_glTestFenceNV: {
			GLuint var_fence = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTestFenceNV: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTestFenceNV\n", err);
		#endif
			DEBUG("gles2(%p): glTestFenceNV(%u )\n", stream, var_fence);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glTestFenceNV(var_fence);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glTestFenceNV");
			break;
		}
		case OP_glGetFenceivNV: {
			GLuint var_fence = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_params(ptr + 8 + 4 + 4 + 4, size_params);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_params, ptr + 8 + 4 + 4 + 4 + size_params, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetFenceivNV: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetFenceivNV\n", err);
		#endif
			DEBUG("gles2(%p): glGetFenceivNV(%u 0x%08x %p(%u) )\n", stream, var_fence, var_pname, (GLint*)(inptr_params.get()), size_params);
			this->glGetFenceivNV(var_fence, var_pname, (GLint*)(inptr_params.get()));
			SET_LASTCALL("glGetFenceivNV");
			break;
		}
		case OP_glFinishFenceNV: {
			GLuint var_fence = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFinishFenceNV: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFinishFenceNV\n", err);
		#endif
			DEBUG("gles2(%p): glFinishFenceNV(%u )\n", stream, var_fence);
			this->glFinishFenceNV(var_fence);
			SET_LASTCALL("glFinishFenceNV");
			break;
		}
		case OP_glSetFenceNV: {
			GLuint var_fence = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_condition = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glSetFenceNV: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glSetFenceNV\n", err);
		#endif
			DEBUG("gles2(%p): glSetFenceNV(%u 0x%08x )\n", stream, var_fence, var_condition);
			this->glSetFenceNV(var_fence, var_condition);
			SET_LASTCALL("glSetFenceNV");
			break;
		}
		case OP_glCoverageMaskNV: {
			GLboolean var_mask = Unpack<GLboolean,uint8_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 1, ptr + 8 + 1, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCoverageMaskNV: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCoverageMaskNV\n", err);
		#endif
			DEBUG("gles2(%p): glCoverageMaskNV(%d )\n", stream, var_mask);
			this->glCoverageMaskNV(var_mask);
			SET_LASTCALL("glCoverageMaskNV");
			break;
		}
		case OP_glCoverageOperationNV: {
			GLenum var_operation = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCoverageOperationNV: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCoverageOperationNV\n", err);
		#endif
			DEBUG("gles2(%p): glCoverageOperationNV(0x%08x )\n", stream, var_operation);
			this->glCoverageOperationNV(var_operation);
			SET_LASTCALL("glCoverageOperationNV");
			break;
		}
		case OP_glGetDriverControlsQCOM: {
			uint32_t size_num __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_num(ptr + 8 + 4, size_num);
			GLsizei var_size = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + size_num);
			uint32_t size_driverControls __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_num + 4);
			InputBuffer inptr_driverControls(ptr + 8 + 4 + size_num + 4 + 4, size_driverControls);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + size_num + 4 + 4 + size_driverControls, ptr + 8 + 4 + size_num + 4 + 4 + size_driverControls, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetDriverControlsQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetDriverControlsQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glGetDriverControlsQCOM(%p(%u) %d %p(%u) )\n", stream, (GLint*)(inptr_num.get()), size_num, var_size, (GLuint*)(inptr_driverControls.get()), size_driverControls);
			this->glGetDriverControlsQCOM((GLint*)(inptr_num.get()), var_size, (GLuint*)(inptr_driverControls.get()));
			SET_LASTCALL("glGetDriverControlsQCOM");
			break;
		}
		case OP_glGetDriverControlStringQCOM: {
			GLuint var_driverControl = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_length(ptr + 8 + 4 + 4 + 4, size_length);
			uint32_t size_driverControlString __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_length);
			InputBuffer inptr_driverControlString(ptr + 8 + 4 + 4 + 4 + size_length + 4, size_driverControlString);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_length + 4 + size_driverControlString, ptr + 8 + 4 + 4 + 4 + size_length + 4 + size_driverControlString, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetDriverControlStringQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetDriverControlStringQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glGetDriverControlStringQCOM(%u %d %p(%u) %p(%u) )\n", stream, var_driverControl, var_bufSize, (GLsizei*)(inptr_length.get()), size_length, (GLchar*)(inptr_driverControlString.get()), size_driverControlString);
			this->glGetDriverControlStringQCOM(var_driverControl, var_bufSize, (GLsizei*)(inptr_length.get()), (GLchar*)(inptr_driverControlString.get()));
			SET_LASTCALL("glGetDriverControlStringQCOM");
			break;
		}
		case OP_glEnableDriverControlQCOM: {
			GLuint var_driverControl = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glEnableDriverControlQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glEnableDriverControlQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glEnableDriverControlQCOM(%u )\n", stream, var_driverControl);
			this->glEnableDriverControlQCOM(var_driverControl);
			SET_LASTCALL("glEnableDriverControlQCOM");
			break;
		}
		case OP_glDisableDriverControlQCOM: {
			GLuint var_driverControl = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDisableDriverControlQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDisableDriverControlQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glDisableDriverControlQCOM(%u )\n", stream, var_driverControl);
			this->glDisableDriverControlQCOM(var_driverControl);
			SET_LASTCALL("glDisableDriverControlQCOM");
			break;
		}
		case OP_glExtGetTexturesQCOM: {
			uint32_t size_textures __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_textures(ptr + 8 + 4, size_textures);
			GLint var_maxTextures = Unpack<GLint,uint32_t>(ptr + 8 + 4 + size_textures);
			uint32_t size_numTextures __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_textures + 4);
			InputBuffer inptr_numTextures(ptr + 8 + 4 + size_textures + 4 + 4, size_numTextures);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + size_textures + 4 + 4 + size_numTextures, ptr + 8 + 4 + size_textures + 4 + 4 + size_numTextures, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glExtGetTexturesQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glExtGetTexturesQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glExtGetTexturesQCOM(%p(%u) %d %p(%u) )\n", stream, (GLuint*)(inptr_textures.get()), size_textures, var_maxTextures, (GLint*)(inptr_numTextures.get()), size_numTextures);
			this->glExtGetTexturesQCOM((GLuint*)(inptr_textures.get()), var_maxTextures, (GLint*)(inptr_numTextures.get()));
			SET_LASTCALL("glExtGetTexturesQCOM");
			break;
		}
		case OP_glExtGetBuffersQCOM: {
			uint32_t size_buffers __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_buffers(ptr + 8 + 4, size_buffers);
			GLint var_maxBuffers = Unpack<GLint,uint32_t>(ptr + 8 + 4 + size_buffers);
			uint32_t size_numBuffers __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_buffers + 4);
			InputBuffer inptr_numBuffers(ptr + 8 + 4 + size_buffers + 4 + 4, size_numBuffers);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + size_buffers + 4 + 4 + size_numBuffers, ptr + 8 + 4 + size_buffers + 4 + 4 + size_numBuffers, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glExtGetBuffersQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glExtGetBuffersQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glExtGetBuffersQCOM(%p(%u) %d %p(%u) )\n", stream, (GLuint*)(inptr_buffers.get()), size_buffers, var_maxBuffers, (GLint*)(inptr_numBuffers.get()), size_numBuffers);
			this->glExtGetBuffersQCOM((GLuint*)(inptr_buffers.get()), var_maxBuffers, (GLint*)(inptr_numBuffers.get()));
			SET_LASTCALL("glExtGetBuffersQCOM");
			break;
		}
		case OP_glExtGetRenderbuffersQCOM: {
			uint32_t size_renderbuffers __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_renderbuffers(ptr + 8 + 4, size_renderbuffers);
			GLint var_maxRenderbuffers = Unpack<GLint,uint32_t>(ptr + 8 + 4 + size_renderbuffers);
			uint32_t size_numRenderbuffers __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_renderbuffers + 4);
			InputBuffer inptr_numRenderbuffers(ptr + 8 + 4 + size_renderbuffers + 4 + 4, size_numRenderbuffers);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + size_renderbuffers + 4 + 4 + size_numRenderbuffers, ptr + 8 + 4 + size_renderbuffers + 4 + 4 + size_numRenderbuffers, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glExtGetRenderbuffersQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glExtGetRenderbuffersQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glExtGetRenderbuffersQCOM(%p(%u) %d %p(%u) )\n", stream, (GLuint*)(inptr_renderbuffers.get()), size_renderbuffers, var_maxRenderbuffers, (GLint*)(inptr_numRenderbuffers.get()), size_numRenderbuffers);
			this->glExtGetRenderbuffersQCOM((GLuint*)(inptr_renderbuffers.get()), var_maxRenderbuffers, (GLint*)(inptr_numRenderbuffers.get()));
			SET_LASTCALL("glExtGetRenderbuffersQCOM");
			break;
		}
		case OP_glExtGetFramebuffersQCOM: {
			uint32_t size_framebuffers __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_framebuffers(ptr + 8 + 4, size_framebuffers);
			GLint var_maxFramebuffers = Unpack<GLint,uint32_t>(ptr + 8 + 4 + size_framebuffers);
			uint32_t size_numFramebuffers __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_framebuffers + 4);
			InputBuffer inptr_numFramebuffers(ptr + 8 + 4 + size_framebuffers + 4 + 4, size_numFramebuffers);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + size_framebuffers + 4 + 4 + size_numFramebuffers, ptr + 8 + 4 + size_framebuffers + 4 + 4 + size_numFramebuffers, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glExtGetFramebuffersQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glExtGetFramebuffersQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glExtGetFramebuffersQCOM(%p(%u) %d %p(%u) )\n", stream, (GLuint*)(inptr_framebuffers.get()), size_framebuffers, var_maxFramebuffers, (GLint*)(inptr_numFramebuffers.get()), size_numFramebuffers);
			this->glExtGetFramebuffersQCOM((GLuint*)(inptr_framebuffers.get()), var_maxFramebuffers, (GLint*)(inptr_numFramebuffers.get()));
			SET_LASTCALL("glExtGetFramebuffersQCOM");
			break;
		}
		case OP_glExtGetTexLevelParameterivQCOM: {
			GLuint var_texture = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_face = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			InputBuffer inptr_params(ptr + 8 + 4 + 4 + 4 + 4 + 4, size_params);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + size_params, ptr + 8 + 4 + 4 + 4 + 4 + 4 + size_params, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glExtGetTexLevelParameterivQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glExtGetTexLevelParameterivQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glExtGetTexLevelParameterivQCOM(%u 0x%08x %d 0x%08x %p(%u) )\n", stream, var_texture, var_face, var_level, var_pname, (GLint*)(inptr_params.get()), size_params);
			this->glExtGetTexLevelParameterivQCOM(var_texture, var_face, var_level, var_pname, (GLint*)(inptr_params.get()));
			SET_LASTCALL("glExtGetTexLevelParameterivQCOM");
			break;
		}
		case OP_glExtTexObjectStateOverrideiQCOM: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLint var_param = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glExtTexObjectStateOverrideiQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glExtTexObjectStateOverrideiQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glExtTexObjectStateOverrideiQCOM(0x%08x 0x%08x %d )\n", stream, var_target, var_pname, var_param);
			this->glExtTexObjectStateOverrideiQCOM(var_target, var_pname, var_param);
			SET_LASTCALL("glExtTexObjectStateOverrideiQCOM");
			break;
		}
		case OP_glExtGetTexSubImageQCOM: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_texels __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_texels(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_texels);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_texels, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_texels, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glExtGetTexSubImageQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glExtGetTexSubImageQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glExtGetTexSubImageQCOM(0x%08x %d %d %d %d %d %d %d 0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_type, (GLvoid*)(inptr_texels.get()), size_texels);
			this->glExtGetTexSubImageQCOM(var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_type, (GLvoid*)(inptr_texels.get()));
			SET_LASTCALL("glExtGetTexSubImageQCOM");
			break;
		}
		case OP_glExtGetBufferPointervQCOM: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_params(ptr + 8 + 4 + 4, size_params);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_params, ptr + 8 + 4 + 4 + size_params, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glExtGetBufferPointervQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glExtGetBufferPointervQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glExtGetBufferPointervQCOM(0x%08x %p(%u) )\n", stream, var_target, (GLvoidptr*)(inptr_params.get()), size_params);
			this->glExtGetBufferPointervQCOM(var_target, (GLvoidptr*)(inptr_params.get()));
			SET_LASTCALL("glExtGetBufferPointervQCOM");
			break;
		}
		case OP_glExtGetShadersQCOM: {
			uint32_t size_shaders __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_shaders(ptr + 8 + 4, size_shaders);
			GLint var_maxShaders = Unpack<GLint,uint32_t>(ptr + 8 + 4 + size_shaders);
			uint32_t size_numShaders __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_shaders + 4);
			InputBuffer inptr_numShaders(ptr + 8 + 4 + size_shaders + 4 + 4, size_numShaders);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + size_shaders + 4 + 4 + size_numShaders, ptr + 8 + 4 + size_shaders + 4 + 4 + size_numShaders, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glExtGetShadersQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glExtGetShadersQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glExtGetShadersQCOM(%p(%u) %d %p(%u) )\n", stream, (GLuint*)(inptr_shaders.get()), size_shaders, var_maxShaders, (GLint*)(inptr_numShaders.get()), size_numShaders);
			this->glExtGetShadersQCOM((GLuint*)(inptr_shaders.get()), var_maxShaders, (GLint*)(inptr_numShaders.get()));
			SET_LASTCALL("glExtGetShadersQCOM");
			break;
		}
		case OP_glExtGetProgramsQCOM: {
			uint32_t size_programs __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_programs(ptr + 8 + 4, size_programs);
			GLint var_maxPrograms = Unpack<GLint,uint32_t>(ptr + 8 + 4 + size_programs);
			uint32_t size_numPrograms __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_programs + 4);
			InputBuffer inptr_numPrograms(ptr + 8 + 4 + size_programs + 4 + 4, size_numPrograms);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + size_programs + 4 + 4 + size_numPrograms, ptr + 8 + 4 + size_programs + 4 + 4 + size_numPrograms, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glExtGetProgramsQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glExtGetProgramsQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glExtGetProgramsQCOM(%p(%u) %d %p(%u) )\n", stream, (GLuint*)(inptr_programs.get()), size_programs, var_maxPrograms, (GLint*)(inptr_numPrograms.get()), size_numPrograms);
			this->glExtGetProgramsQCOM((GLuint*)(inptr_programs.get()), var_maxPrograms, (GLint*)(inptr_numPrograms.get()));
			SET_LASTCALL("glExtGetProgramsQCOM");
			break;
		}
		case OP_glExtIsProgramBinaryQCOM: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glExtIsProgramBinaryQCOM: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glExtIsProgramBinaryQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glExtIsProgramBinaryQCOM(%u )\n", stream, var_program);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glExtIsProgramBinaryQCOM(var_program);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glExtIsProgramBinaryQCOM");
			break;
		}
		case OP_glExtGetProgramBinarySourceQCOM: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_shadertype = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_source __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_source(ptr + 8 + 4 + 4 + 4, size_source);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_source);
			InputBuffer inptr_length(ptr + 8 + 4 + 4 + 4 + size_source + 4, size_length);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_source + 4 + size_length, ptr + 8 + 4 + 4 + 4 + size_source + 4 + size_length, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glExtGetProgramBinarySourceQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glExtGetProgramBinarySourceQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glExtGetProgramBinarySourceQCOM(%u 0x%08x %p(%u) %p(%u) )\n", stream, var_program, var_shadertype, (GLchar*)(inptr_source.get()), size_source, (GLint*)(inptr_length.get()), size_length);
			this->glExtGetProgramBinarySourceQCOM(var_program, var_shadertype, (GLchar*)(inptr_source.get()), (GLint*)(inptr_length.get()));
			SET_LASTCALL("glExtGetProgramBinarySourceQCOM");
			break;
		}
		case OP_glStartTilingQCOM: {
			GLuint var_x = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_y = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLuint var_width = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_height = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLbitfield var_preserveMask = Unpack<GLbitfield,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glStartTilingQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glStartTilingQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glStartTilingQCOM(%u %u %u %u 0x%08x )\n", stream, var_x, var_y, var_width, var_height, var_preserveMask);
			this->glStartTilingQCOM(var_x, var_y, var_width, var_height, var_preserveMask);
			SET_LASTCALL("glStartTilingQCOM");
			break;
		}
		case OP_glEndTilingQCOM: {
			GLbitfield var_preserveMask = Unpack<GLbitfield,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glEndTilingQCOM: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glEndTilingQCOM\n", err);
		#endif
			DEBUG("gles2(%p): glEndTilingQCOM(0x%08x )\n", stream, var_preserveMask);
			this->glEndTilingQCOM(var_preserveMask);
			SET_LASTCALL("glEndTilingQCOM");
			break;
		}
		case OP_glVertexAttribPointerData: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_size = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_normalized = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_stride = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 1 + 4 + 4, size_data);
			GLuint var_datalen = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1 + 4 + 4 + size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 1 + 4 + 4 + size_data + 4, ptr + 8 + 4 + 4 + 4 + 1 + 4 + 4 + size_data + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttribPointerData: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttribPointerData\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttribPointerData(%u %d 0x%08x %d %d %p(%u) %u )\n", stream, var_indx, var_size, var_type, var_normalized, var_stride, (void*)(inptr_data.get()), size_data, var_datalen);
			this->glVertexAttribPointerData(this, var_indx, var_size, var_type, var_normalized, var_stride, (void*)(inptr_data.get()), var_datalen);
			SET_LASTCALL("glVertexAttribPointerData");
			break;
		}
		case OP_glVertexAttribPointerOffset: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_size = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_normalized = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_stride = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 1 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 1 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttribPointerOffset: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttribPointerOffset\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttribPointerOffset(%u %d 0x%08x %d %d %u )\n", stream, var_indx, var_size, var_type, var_normalized, var_stride, var_offset);
			this->glVertexAttribPointerOffset(this, var_indx, var_size, var_type, var_normalized, var_stride, var_offset);
			SET_LASTCALL("glVertexAttribPointerOffset");
			break;
		}
		case OP_glDrawElementsOffset: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawElementsOffset: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawElementsOffset\n", err);
		#endif
			DEBUG("gles2(%p): glDrawElementsOffset(0x%08x %d 0x%08x %u )\n", stream, var_mode, var_count, var_type, var_offset);
			this->glDrawElementsOffset(this, var_mode, var_count, var_type, var_offset);
			SET_LASTCALL("glDrawElementsOffset");
			break;
		}
		case OP_glDrawElementsData: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4, size_data);
			GLuint var_datalen = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_data + 4, ptr + 8 + 4 + 4 + 4 + 4 + size_data + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawElementsData: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawElementsData\n", err);
		#endif
			DEBUG("gles2(%p): glDrawElementsData(0x%08x %d 0x%08x %p(%u) %u )\n", stream, var_mode, var_count, var_type, (void*)(inptr_data.get()), size_data, var_datalen);
			this->glDrawElementsData(this, var_mode, var_count, var_type, (void*)(inptr_data.get()), var_datalen);
			SET_LASTCALL("glDrawElementsData");
			break;
		}
		case OP_glGetCompressedTextureFormats: {
			int var_count = Unpack<int,uint32_t>(ptr + 8);
			uint32_t size_formats __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetCompressedTextureFormats: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_formats;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_formats(&tmpBuf[0], size_formats);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetCompressedTextureFormats\n", err);
		#endif
			DEBUG("gles2(%p): glGetCompressedTextureFormats(%d %p(%u) )\n", stream, var_count, (GLint*)(outptr_formats.get()), size_formats);
			this->glGetCompressedTextureFormats(this, var_count, (GLint*)(outptr_formats.get()));
			outptr_formats.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetCompressedTextureFormats");
			break;
		}
		case OP_glShaderString: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_string __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_string(ptr + 8 + 4 + 4, size_string);
			GLsizei var_len = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + size_string);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_string + 4, ptr + 8 + 4 + 4 + size_string + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glShaderString: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glShaderString\n", err);
		#endif
			DEBUG("gles2(%p): glShaderString(%u %p(%u) %d )\n", stream, var_shader, (const GLchar*)(inptr_string.get()), size_string, var_len);
			this->glShaderString(this, var_shader, (const GLchar*)(inptr_string.get()), var_len);
			SET_LASTCALL("glShaderString");
			break;
		}
		case OP_glFinishRoundTrip: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8, ptr + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFinishRoundTrip: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFinishRoundTrip\n", err);
		#endif
			DEBUG("gles2(%p): glFinishRoundTrip()\n", stream);
			*(int *)(&tmpBuf[0]) = 			this->glFinishRoundTrip(this);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glFinishRoundTrip");
			break;
		}
		case OP_glGenVertexArrays: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_arrays __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGenVertexArrays: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_arrays;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_arrays(&tmpBuf[0], size_arrays);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGenVertexArrays\n", err);
		#endif
			DEBUG("gles2(%p): glGenVertexArrays(%d %p(%u) )\n", stream, var_n, (GLuint*)(outptr_arrays.get()), size_arrays);
			this->glGenVertexArrays(var_n, (GLuint*)(outptr_arrays.get()));
			outptr_arrays.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenVertexArrays");
			break;
		}
		case OP_glBindVertexArray: {
			GLuint var_array = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBindVertexArray: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBindVertexArray\n", err);
		#endif
			DEBUG("gles2(%p): glBindVertexArray(%u )\n", stream, var_array);
			this->glBindVertexArray(var_array);
			SET_LASTCALL("glBindVertexArray");
			break;
		}
		case OP_glDeleteVertexArrays: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_arrays __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_arrays(ptr + 8 + 4 + 4, size_arrays);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_arrays, ptr + 8 + 4 + 4 + size_arrays, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteVertexArrays: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteVertexArrays\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteVertexArrays(%d %p(%u) )\n", stream, var_n, (const GLuint*)(inptr_arrays.get()), size_arrays);
			this->glDeleteVertexArrays(var_n, (const GLuint*)(inptr_arrays.get()));
			SET_LASTCALL("glDeleteVertexArrays");
			break;
		}
		case OP_glIsVertexArray: {
			GLuint var_array = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsVertexArray: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsVertexArray\n", err);
		#endif
			DEBUG("gles2(%p): glIsVertexArray(%u )\n", stream, var_array);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsVertexArray(var_array);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsVertexArray");
			break;
		}
		case OP_glMapBufferRange: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLintptr var_offset = Unpack<GLintptr,uint32_t>(ptr + 8 + 4);
			GLsizeiptr var_length = Unpack<GLsizeiptr,uint32_t>(ptr + 8 + 4 + 4);
			GLbitfield var_access = Unpack<GLbitfield,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glMapBufferRange: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glMapBufferRange\n", err);
		#endif
			DEBUG("gles2(%p): glMapBufferRange(0x%08x 0x%08lx 0x%08lx 0x%08x )\n", stream, var_target, var_offset, var_length, var_access);
			this->glMapBufferRange(var_target, var_offset, var_length, var_access);
			SET_LASTCALL("glMapBufferRange");
			break;
		}
		case OP_glUnmapBuffer: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUnmapBuffer: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUnmapBuffer\n", err);
		#endif
			DEBUG("gles2(%p): glUnmapBuffer(0x%08x )\n", stream, var_target);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glUnmapBuffer(var_target);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glUnmapBuffer");
			break;
		}
		case OP_glFlushMappedBufferRange: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLintptr var_offset = Unpack<GLintptr,uint32_t>(ptr + 8 + 4);
			GLsizeiptr var_length = Unpack<GLsizeiptr,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFlushMappedBufferRange: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFlushMappedBufferRange\n", err);
		#endif
			DEBUG("gles2(%p): glFlushMappedBufferRange(0x%08x 0x%08lx 0x%08lx )\n", stream, var_target, var_offset, var_length);
			this->glFlushMappedBufferRange(var_target, var_offset, var_length);
			SET_LASTCALL("glFlushMappedBufferRange");
			break;
		}
		case OP_glMapBufferRangeAEMU: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLintptr var_offset = Unpack<GLintptr,uint32_t>(ptr + 8 + 4);
			GLsizeiptr var_length = Unpack<GLsizeiptr,uint32_t>(ptr + 8 + 4 + 4);
			GLbitfield var_access = Unpack<GLbitfield,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_mapped __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glMapBufferRangeAEMU: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_mapped;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_mapped(&tmpBuf[0], size_mapped);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glMapBufferRangeAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glMapBufferRangeAEMU(0x%08x 0x%08lx 0x%08lx 0x%08x %p(%u) )\n", stream, var_target, var_offset, var_length, var_access, (void*)(outptr_mapped.get()), size_mapped);
			this->glMapBufferRangeAEMU(this, var_target, var_offset, var_length, var_access, size_mapped == 0 ? nullptr : (void*)(outptr_mapped.get()));
			outptr_mapped.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glMapBufferRangeAEMU");
			break;
		}
		case OP_glUnmapBufferAEMU: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLintptr var_offset = Unpack<GLintptr,uint32_t>(ptr + 8 + 4);
			GLsizeiptr var_length = Unpack<GLsizeiptr,uint32_t>(ptr + 8 + 4 + 4);
			GLbitfield var_access = Unpack<GLbitfield,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_guest_buffer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			InputBuffer inptr_guest_buffer(ptr + 8 + 4 + 4 + 4 + 4 + 4, size_guest_buffer);
			uint32_t size_out_res __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + size_guest_buffer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + size_guest_buffer + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + size_guest_buffer + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUnmapBufferAEMU: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_out_res;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_out_res(&tmpBuf[0], size_out_res);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUnmapBufferAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glUnmapBufferAEMU(0x%08x 0x%08lx 0x%08lx 0x%08x %p(%u) %p(%u) )\n", stream, var_target, var_offset, var_length, var_access, (void*)(inptr_guest_buffer.get()), size_guest_buffer, (GLboolean*)(outptr_out_res.get()), size_out_res);
			this->glUnmapBufferAEMU(this, var_target, var_offset, var_length, var_access, size_guest_buffer == 0 ? nullptr : (void*)(inptr_guest_buffer.get()), (GLboolean*)(outptr_out_res.get()));
			outptr_out_res.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glUnmapBufferAEMU");
			break;
		}
		case OP_glFlushMappedBufferRangeAEMU: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLintptr var_offset = Unpack<GLintptr,uint32_t>(ptr + 8 + 4);
			GLsizeiptr var_length = Unpack<GLsizeiptr,uint32_t>(ptr + 8 + 4 + 4);
			GLbitfield var_access = Unpack<GLbitfield,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_guest_buffer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			InputBuffer inptr_guest_buffer(ptr + 8 + 4 + 4 + 4 + 4 + 4, size_guest_buffer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + size_guest_buffer, ptr + 8 + 4 + 4 + 4 + 4 + 4 + size_guest_buffer, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFlushMappedBufferRangeAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFlushMappedBufferRangeAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glFlushMappedBufferRangeAEMU(0x%08x 0x%08lx 0x%08lx 0x%08x %p(%u) )\n", stream, var_target, var_offset, var_length, var_access, (void*)(inptr_guest_buffer.get()), size_guest_buffer);
			this->glFlushMappedBufferRangeAEMU(this, var_target, var_offset, var_length, var_access, size_guest_buffer == 0 ? nullptr : (void*)(inptr_guest_buffer.get()));
			SET_LASTCALL("glFlushMappedBufferRangeAEMU");
			break;
		}
		case OP_glReadPixelsOffsetAEMU: {
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glReadPixelsOffsetAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glReadPixelsOffsetAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glReadPixelsOffsetAEMU(%d %d %d %d 0x%08x 0x%08x %u )\n", stream, var_x, var_y, var_width, var_height, var_format, var_type, var_offset);
			this->glReadPixelsOffsetAEMU(this, var_x, var_y, var_width, var_height, var_format, var_type, var_offset);
			SET_LASTCALL("glReadPixelsOffsetAEMU");
			break;
		}
		case OP_glCompressedTexImage2DOffsetAEMU: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_imageSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCompressedTexImage2DOffsetAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCompressedTexImage2DOffsetAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glCompressedTexImage2DOffsetAEMU(0x%08x %d 0x%08x %d %d %d %d %u )\n", stream, var_target, var_level, var_internalformat, var_width, var_height, var_border, var_imageSize, var_offset);
			this->glCompressedTexImage2DOffsetAEMU(this, var_target, var_level, var_internalformat, var_width, var_height, var_border, var_imageSize, var_offset);
			SET_LASTCALL("glCompressedTexImage2DOffsetAEMU");
			break;
		}
		case OP_glCompressedTexSubImage2DOffsetAEMU: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_imageSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCompressedTexSubImage2DOffsetAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCompressedTexSubImage2DOffsetAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glCompressedTexSubImage2DOffsetAEMU(0x%08x %d %d %d %d %d 0x%08x %d %u )\n", stream, var_target, var_level, var_xoffset, var_yoffset, var_width, var_height, var_format, var_imageSize, var_offset);
			this->glCompressedTexSubImage2DOffsetAEMU(this, var_target, var_level, var_xoffset, var_yoffset, var_width, var_height, var_format, var_imageSize, var_offset);
			SET_LASTCALL("glCompressedTexSubImage2DOffsetAEMU");
			break;
		}
		case OP_glTexImage2DOffsetAEMU: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_internalformat = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexImage2DOffsetAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexImage2DOffsetAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glTexImage2DOffsetAEMU(0x%08x %d %d %d %d %d 0x%08x 0x%08x %u )\n", stream, var_target, var_level, var_internalformat, var_width, var_height, var_border, var_format, var_type, var_offset);
			this->glTexImage2DOffsetAEMU(this, var_target, var_level, var_internalformat, var_width, var_height, var_border, var_format, var_type, var_offset);
			SET_LASTCALL("glTexImage2DOffsetAEMU");
			break;
		}
		case OP_glTexSubImage2DOffsetAEMU: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexSubImage2DOffsetAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexSubImage2DOffsetAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glTexSubImage2DOffsetAEMU(0x%08x %d %d %d %d %d 0x%08x 0x%08x %u )\n", stream, var_target, var_level, var_xoffset, var_yoffset, var_width, var_height, var_format, var_type, var_offset);
			this->glTexSubImage2DOffsetAEMU(this, var_target, var_level, var_xoffset, var_yoffset, var_width, var_height, var_format, var_type, var_offset);
			SET_LASTCALL("glTexSubImage2DOffsetAEMU");
			break;
		}
		case OP_glBindBufferRange: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLuint var_buffer = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			GLintptr var_offset = Unpack<GLintptr,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizeiptr var_size = Unpack<GLsizeiptr,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBindBufferRange: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBindBufferRange\n", err);
		#endif
			DEBUG("gles2(%p): glBindBufferRange(0x%08x %u %u 0x%08lx 0x%08lx )\n", stream, var_target, var_index, var_buffer, var_offset, var_size);
			this->glBindBufferRange(var_target, var_index, var_buffer, var_offset, var_size);
			SET_LASTCALL("glBindBufferRange");
			break;
		}
		case OP_glBindBufferBase: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLuint var_buffer = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBindBufferBase: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBindBufferBase\n", err);
		#endif
			DEBUG("gles2(%p): glBindBufferBase(0x%08x %u %u )\n", stream, var_target, var_index, var_buffer);
			this->glBindBufferBase(var_target, var_index, var_buffer);
			SET_LASTCALL("glBindBufferBase");
			break;
		}
		case OP_glCopyBufferSubData: {
			GLenum var_readtarget = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_writetarget = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLintptr var_readoffset = Unpack<GLintptr,uint32_t>(ptr + 8 + 4 + 4);
			GLintptr var_writeoffset = Unpack<GLintptr,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizeiptr var_size = Unpack<GLsizeiptr,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCopyBufferSubData: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCopyBufferSubData\n", err);
		#endif
			DEBUG("gles2(%p): glCopyBufferSubData(0x%08x 0x%08x 0x%08lx 0x%08lx 0x%08lx )\n", stream, var_readtarget, var_writetarget, var_readoffset, var_writeoffset, var_size);
			this->glCopyBufferSubData(var_readtarget, var_writetarget, var_readoffset, var_writeoffset, var_size);
			SET_LASTCALL("glCopyBufferSubData");
			break;
		}
		case OP_glClearBufferiv: {
			GLenum var_buffer = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_drawBuffer = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glClearBufferiv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glClearBufferiv\n", err);
		#endif
			DEBUG("gles2(%p): glClearBufferiv(0x%08x %d %p(%u) )\n", stream, var_buffer, var_drawBuffer, (const GLint*)(inptr_value.get()), size_value);
			this->glClearBufferiv(var_buffer, var_drawBuffer, (const GLint*)(inptr_value.get()));
			SET_LASTCALL("glClearBufferiv");
			break;
		}
		case OP_glClearBufferuiv: {
			GLenum var_buffer = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_drawBuffer = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glClearBufferuiv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glClearBufferuiv\n", err);
		#endif
			DEBUG("gles2(%p): glClearBufferuiv(0x%08x %d %p(%u) )\n", stream, var_buffer, var_drawBuffer, (const GLuint*)(inptr_value.get()), size_value);
			this->glClearBufferuiv(var_buffer, var_drawBuffer, (const GLuint*)(inptr_value.get()));
			SET_LASTCALL("glClearBufferuiv");
			break;
		}
		case OP_glClearBufferfv: {
			GLenum var_buffer = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_drawBuffer = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glClearBufferfv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glClearBufferfv\n", err);
		#endif
			DEBUG("gles2(%p): glClearBufferfv(0x%08x %d %p(%u) )\n", stream, var_buffer, var_drawBuffer, (const GLfloat*)(inptr_value.get()), size_value);
			this->glClearBufferfv(var_buffer, var_drawBuffer, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glClearBufferfv");
			break;
		}
		case OP_glClearBufferfi: {
			GLenum var_buffer = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_drawBuffer = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLfloat var_depth = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_stencil = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glClearBufferfi: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glClearBufferfi\n", err);
		#endif
			DEBUG("gles2(%p): glClearBufferfi(0x%08x %d %f %d )\n", stream, var_buffer, var_drawBuffer, var_depth, var_stencil);
			this->glClearBufferfi(var_buffer, var_drawBuffer, var_depth, var_stencil);
			SET_LASTCALL("glClearBufferfi");
			break;
		}
		case OP_glGetBufferParameteri64v: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_value = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + size_data, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetBufferParameteri64v: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetBufferParameteri64v\n", err);
		#endif
			DEBUG("gles2(%p): glGetBufferParameteri64v(0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_value, (GLint64*)(inptr_data.get()), size_data);
			this->glGetBufferParameteri64v(var_target, var_value, (GLint64*)(inptr_data.get()));
			SET_LASTCALL("glGetBufferParameteri64v");
			break;
		}
		case OP_glGetBufferPointerv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_params(ptr + 8 + 4 + 4 + 4, size_params);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_params, ptr + 8 + 4 + 4 + 4 + size_params, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetBufferPointerv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetBufferPointerv\n", err);
		#endif
			DEBUG("gles2(%p): glGetBufferPointerv(0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_pname, (GLvoid**)(inptr_params.get()), size_params);
			this->glGetBufferPointerv(var_target, var_pname, (GLvoid**)(inptr_params.get()));
			SET_LASTCALL("glGetBufferPointerv");
			break;
		}
		case OP_glUniformBlockBinding: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_uniformBlockIndex = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLuint var_uniformBlockBinding = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniformBlockBinding: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniformBlockBinding\n", err);
		#endif
			DEBUG("gles2(%p): glUniformBlockBinding(%u %u %u )\n", stream, var_program, var_uniformBlockIndex, var_uniformBlockBinding);
			this->glUniformBlockBinding(var_program, var_uniformBlockIndex, var_uniformBlockBinding);
			SET_LASTCALL("glUniformBlockBinding");
			break;
		}
		case OP_glGetUniformBlockIndex: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_uniformBlockName __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_uniformBlockName(ptr + 8 + 4 + 4, size_uniformBlockName);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_uniformBlockName, ptr + 8 + 4 + 4 + size_uniformBlockName, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetUniformBlockIndex: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLuint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetUniformBlockIndex\n", err);
		#endif
			DEBUG("gles2(%p): glGetUniformBlockIndex(%u %p(%u) )\n", stream, var_program, (const GLchar*)(inptr_uniformBlockName.get()), size_uniformBlockName);
			*(GLuint *)(&tmpBuf[0]) = 			this->glGetUniformBlockIndex(var_program, (const GLchar*)(inptr_uniformBlockName.get()));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetUniformBlockIndex");
			break;
		}
		case OP_glGetUniformIndices: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_uniformCount = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_uniformNames __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_uniformNames(ptr + 8 + 4 + 4 + 4, size_uniformNames);
			uint32_t size_uniformIndices __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_uniformNames);
			InputBuffer inptr_uniformIndices(ptr + 8 + 4 + 4 + 4 + size_uniformNames + 4, size_uniformIndices);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_uniformNames + 4 + size_uniformIndices, ptr + 8 + 4 + 4 + 4 + size_uniformNames + 4 + size_uniformIndices, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetUniformIndices: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetUniformIndices\n", err);
		#endif
			DEBUG("gles2(%p): glGetUniformIndices(%u %d %p(%u) %p(%u) )\n", stream, var_program, var_uniformCount, (const GLchar**)(inptr_uniformNames.get()), size_uniformNames, (GLuint*)(inptr_uniformIndices.get()), size_uniformIndices);
			this->glGetUniformIndices(var_program, var_uniformCount, (const GLchar**)(inptr_uniformNames.get()), (GLuint*)(inptr_uniformIndices.get()));
			SET_LASTCALL("glGetUniformIndices");
			break;
		}
		case OP_glGetUniformIndicesAEMU: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_uniformCount = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_packedUniformNames __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_packedUniformNames(ptr + 8 + 4 + 4 + 4, size_packedUniformNames);
			GLsizei var_packedLen = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_packedUniformNames);
			uint32_t size_uniformIndices __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_packedUniformNames + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_packedUniformNames + 4 + 4, ptr + 8 + 4 + 4 + 4 + size_packedUniformNames + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetUniformIndicesAEMU: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_uniformIndices;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_uniformIndices(&tmpBuf[0], size_uniformIndices);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetUniformIndicesAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glGetUniformIndicesAEMU(%u %d %p(%u) %d %p(%u) )\n", stream, var_program, var_uniformCount, (const GLchar*)(inptr_packedUniformNames.get()), size_packedUniformNames, var_packedLen, (GLuint*)(outptr_uniformIndices.get()), size_uniformIndices);
			this->glGetUniformIndicesAEMU(this, var_program, var_uniformCount, (const GLchar*)(inptr_packedUniformNames.get()), var_packedLen, (GLuint*)(outptr_uniformIndices.get()));
			outptr_uniformIndices.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetUniformIndicesAEMU");
			break;
		}
		case OP_glGetActiveUniformBlockiv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_uniformBlockIndex = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetActiveUniformBlockiv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetActiveUniformBlockiv\n", err);
		#endif
			DEBUG("gles2(%p): glGetActiveUniformBlockiv(%u %u 0x%08x %p(%u) )\n", stream, var_program, var_uniformBlockIndex, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetActiveUniformBlockiv(var_program, var_uniformBlockIndex, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetActiveUniformBlockiv");
			break;
		}
		case OP_glGetActiveUniformBlockName: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_uniformBlockIndex = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_uniformBlockName __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetActiveUniformBlockName: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_uniformBlockName;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_uniformBlockName(&tmpBuf[0 + size_length], size_uniformBlockName);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetActiveUniformBlockName\n", err);
		#endif
			DEBUG("gles2(%p): glGetActiveUniformBlockName(%u %u %d %p(%u) %p(%u) )\n", stream, var_program, var_uniformBlockIndex, var_bufSize, (GLsizei*)(outptr_length.get()), size_length, (GLchar*)(outptr_uniformBlockName.get()), size_uniformBlockName);
			this->glGetActiveUniformBlockName(var_program, var_uniformBlockIndex, var_bufSize, size_length == 0 ? nullptr : (GLsizei*)(outptr_length.get()), size_uniformBlockName == 0 ? nullptr : (GLchar*)(outptr_uniformBlockName.get()));
			outptr_length.flush();
			outptr_uniformBlockName.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetActiveUniformBlockName");
			break;
		}
		case OP_glUniform1ui: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLuint var_v0 = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform1ui: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform1ui\n", err);
		#endif
			DEBUG("gles2(%p): glUniform1ui(%d %u )\n", stream, var_location, var_v0);
			this->glUniform1ui(var_location, var_v0);
			SET_LASTCALL("glUniform1ui");
			break;
		}
		case OP_glUniform2ui: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLuint var_v0 = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLuint var_v1 = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform2ui: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform2ui\n", err);
		#endif
			DEBUG("gles2(%p): glUniform2ui(%d %u %u )\n", stream, var_location, var_v0, var_v1);
			this->glUniform2ui(var_location, var_v0, var_v1);
			SET_LASTCALL("glUniform2ui");
			break;
		}
		case OP_glUniform3ui: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLuint var_v0 = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLuint var_v1 = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_v2 = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform3ui: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform3ui\n", err);
		#endif
			DEBUG("gles2(%p): glUniform3ui(%d %u %u %u )\n", stream, var_location, var_v0, var_v1, var_v2);
			this->glUniform3ui(var_location, var_v0, var_v1, var_v2);
			SET_LASTCALL("glUniform3ui");
			break;
		}
		case OP_glUniform4ui: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_v0 = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLuint var_v1 = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_v2 = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLuint var_v3 = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform4ui: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform4ui\n", err);
		#endif
			DEBUG("gles2(%p): glUniform4ui(%d %d %u %u %u )\n", stream, var_location, var_v0, var_v1, var_v2, var_v3);
			this->glUniform4ui(var_location, var_v0, var_v1, var_v2, var_v3);
			SET_LASTCALL("glUniform4ui");
			break;
		}
		case OP_glUniform1uiv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform1uiv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform1uiv\n", err);
		#endif
			DEBUG("gles2(%p): glUniform1uiv(%d %d %p(%u) )\n", stream, var_location, var_count, (const GLuint*)(inptr_value.get()), size_value);
			this->glUniform1uiv(var_location, var_count, (const GLuint*)(inptr_value.get()));
			SET_LASTCALL("glUniform1uiv");
			break;
		}
		case OP_glUniform2uiv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform2uiv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform2uiv\n", err);
		#endif
			DEBUG("gles2(%p): glUniform2uiv(%d %d %p(%u) )\n", stream, var_location, var_count, (const GLuint*)(inptr_value.get()), size_value);
			this->glUniform2uiv(var_location, var_count, (const GLuint*)(inptr_value.get()));
			SET_LASTCALL("glUniform2uiv");
			break;
		}
		case OP_glUniform3uiv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform3uiv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform3uiv\n", err);
		#endif
			DEBUG("gles2(%p): glUniform3uiv(%d %d %p(%u) )\n", stream, var_location, var_count, (const GLuint*)(inptr_value.get()), size_value);
			this->glUniform3uiv(var_location, var_count, (const GLuint*)(inptr_value.get()));
			SET_LASTCALL("glUniform3uiv");
			break;
		}
		case OP_glUniform4uiv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniform4uiv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniform4uiv\n", err);
		#endif
			DEBUG("gles2(%p): glUniform4uiv(%d %d %p(%u) )\n", stream, var_location, var_count, (const GLuint*)(inptr_value.get()), size_value);
			this->glUniform4uiv(var_location, var_count, (const GLuint*)(inptr_value.get()));
			SET_LASTCALL("glUniform4uiv");
			break;
		}
		case OP_glUniformMatrix2x3fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniformMatrix2x3fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniformMatrix2x3fv\n", err);
		#endif
			DEBUG("gles2(%p): glUniformMatrix2x3fv(%d %d %d %p(%u) )\n", stream, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glUniformMatrix2x3fv(var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glUniformMatrix2x3fv");
			break;
		}
		case OP_glUniformMatrix3x2fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniformMatrix3x2fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniformMatrix3x2fv\n", err);
		#endif
			DEBUG("gles2(%p): glUniformMatrix3x2fv(%d %d %d %p(%u) )\n", stream, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glUniformMatrix3x2fv(var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glUniformMatrix3x2fv");
			break;
		}
		case OP_glUniformMatrix2x4fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniformMatrix2x4fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniformMatrix2x4fv\n", err);
		#endif
			DEBUG("gles2(%p): glUniformMatrix2x4fv(%d %d %d %p(%u) )\n", stream, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glUniformMatrix2x4fv(var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glUniformMatrix2x4fv");
			break;
		}
		case OP_glUniformMatrix4x2fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniformMatrix4x2fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniformMatrix4x2fv\n", err);
		#endif
			DEBUG("gles2(%p): glUniformMatrix4x2fv(%d %d %d %p(%u) )\n", stream, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glUniformMatrix4x2fv(var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glUniformMatrix4x2fv");
			break;
		}
		case OP_glUniformMatrix3x4fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniformMatrix3x4fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniformMatrix3x4fv\n", err);
		#endif
			DEBUG("gles2(%p): glUniformMatrix3x4fv(%d %d %d %p(%u) )\n", stream, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glUniformMatrix3x4fv(var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glUniformMatrix3x4fv");
			break;
		}
		case OP_glUniformMatrix4x3fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUniformMatrix4x3fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUniformMatrix4x3fv\n", err);
		#endif
			DEBUG("gles2(%p): glUniformMatrix4x3fv(%d %d %d %p(%u) )\n", stream, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glUniformMatrix4x3fv(var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glUniformMatrix4x3fv");
			break;
		}
		case OP_glGetUniformuiv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetUniformuiv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetUniformuiv\n", err);
		#endif
			DEBUG("gles2(%p): glGetUniformuiv(%u %d %p(%u) )\n", stream, var_program, var_location, (GLuint*)(outptr_params.get()), size_params);
			this->glGetUniformuiv(var_program, var_location, (GLuint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetUniformuiv");
			break;
		}
		case OP_glGetActiveUniformsiv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_uniformCount = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_uniformIndices __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_uniformIndices(ptr + 8 + 4 + 4 + 4, size_uniformIndices);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_uniformIndices);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_uniformIndices + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_uniformIndices + 4 + 4, ptr + 8 + 4 + 4 + 4 + size_uniformIndices + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetActiveUniformsiv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetActiveUniformsiv\n", err);
		#endif
			DEBUG("gles2(%p): glGetActiveUniformsiv(%u %d %p(%u) 0x%08x %p(%u) )\n", stream, var_program, var_uniformCount, (const GLuint*)(inptr_uniformIndices.get()), size_uniformIndices, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetActiveUniformsiv(var_program, var_uniformCount, (const GLuint*)(inptr_uniformIndices.get()), var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetActiveUniformsiv");
			break;
		}
		case OP_glVertexAttribI4i: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_v0 = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_v1 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_v2 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_v3 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttribI4i: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttribI4i\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttribI4i(%u %d %d %d %d )\n", stream, var_index, var_v0, var_v1, var_v2, var_v3);
			this->glVertexAttribI4i(var_index, var_v0, var_v1, var_v2, var_v3);
			SET_LASTCALL("glVertexAttribI4i");
			break;
		}
		case OP_glVertexAttribI4ui: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_v0 = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLuint var_v1 = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_v2 = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLuint var_v3 = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttribI4ui: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttribI4ui\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttribI4ui(%u %u %u %u %u )\n", stream, var_index, var_v0, var_v1, var_v2, var_v3);
			this->glVertexAttribI4ui(var_index, var_v0, var_v1, var_v2, var_v3);
			SET_LASTCALL("glVertexAttribI4ui");
			break;
		}
		case OP_glVertexAttribI4iv: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_v __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + size_v, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttribI4iv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttribI4iv\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttribI4iv(%u %p(%u) )\n", stream, var_index, (const GLint*)(inptr_v.get()), size_v);
			this->glVertexAttribI4iv(var_index, (const GLint*)(inptr_v.get()));
			SET_LASTCALL("glVertexAttribI4iv");
			break;
		}
		case OP_glVertexAttribI4uiv: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_v __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + size_v, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttribI4uiv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttribI4uiv\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttribI4uiv(%u %p(%u) )\n", stream, var_index, (const GLuint*)(inptr_v.get()), size_v);
			this->glVertexAttribI4uiv(var_index, (const GLuint*)(inptr_v.get()));
			SET_LASTCALL("glVertexAttribI4uiv");
			break;
		}
		case OP_glVertexAttribIPointer: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_size = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_stride = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_pointer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			InputBuffer inptr_pointer(ptr + 8 + 4 + 4 + 4 + 4 + 4, size_pointer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + size_pointer, ptr + 8 + 4 + 4 + 4 + 4 + 4 + size_pointer, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttribIPointer: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttribIPointer\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttribIPointer(%u %d 0x%08x %d %p(%u) )\n", stream, var_index, var_size, var_type, var_stride, (const GLvoid*)(inptr_pointer.get()), size_pointer);
			this->glVertexAttribIPointer(var_index, var_size, var_type, var_stride, (const GLvoid*)(inptr_pointer.get()));
			SET_LASTCALL("glVertexAttribIPointer");
			break;
		}
		case OP_glVertexAttribIPointerOffsetAEMU: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_size = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_stride = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttribIPointerOffsetAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttribIPointerOffsetAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttribIPointerOffsetAEMU(%u %d 0x%08x %d %u )\n", stream, var_index, var_size, var_type, var_stride, var_offset);
			this->glVertexAttribIPointerOffsetAEMU(this, var_index, var_size, var_type, var_stride, var_offset);
			SET_LASTCALL("glVertexAttribIPointerOffsetAEMU");
			break;
		}
		case OP_glVertexAttribIPointerDataAEMU: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_size = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_stride = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4 + 4, size_data);
			GLuint var_datalen = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + size_data + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + size_data + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttribIPointerDataAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttribIPointerDataAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttribIPointerDataAEMU(%u %d 0x%08x %d %p(%u) %u )\n", stream, var_index, var_size, var_type, var_stride, (void*)(inptr_data.get()), size_data, var_datalen);
			this->glVertexAttribIPointerDataAEMU(this, var_index, var_size, var_type, var_stride, (void*)(inptr_data.get()), var_datalen);
			SET_LASTCALL("glVertexAttribIPointerDataAEMU");
			break;
		}
		case OP_glGetVertexAttribIiv: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetVertexAttribIiv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetVertexAttribIiv\n", err);
		#endif
			DEBUG("gles2(%p): glGetVertexAttribIiv(%u 0x%08x %p(%u) )\n", stream, var_index, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetVertexAttribIiv(var_index, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetVertexAttribIiv");
			break;
		}
		case OP_glGetVertexAttribIuiv: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetVertexAttribIuiv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetVertexAttribIuiv\n", err);
		#endif
			DEBUG("gles2(%p): glGetVertexAttribIuiv(%u 0x%08x %p(%u) )\n", stream, var_index, var_pname, (GLuint*)(outptr_params.get()), size_params);
			this->glGetVertexAttribIuiv(var_index, var_pname, (GLuint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetVertexAttribIuiv");
			break;
		}
		case OP_glVertexAttribDivisor: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_divisor = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttribDivisor: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttribDivisor\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttribDivisor(%u %u )\n", stream, var_index, var_divisor);
			this->glVertexAttribDivisor(var_index, var_divisor);
			SET_LASTCALL("glVertexAttribDivisor");
			break;
		}
		case OP_glDrawArraysInstanced: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_first = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_primcount = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawArraysInstanced: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawArraysInstanced\n", err);
		#endif
			DEBUG("gles2(%p): glDrawArraysInstanced(0x%08x %d %d %d )\n", stream, var_mode, var_first, var_count, var_primcount);
			this->glDrawArraysInstanced(var_mode, var_first, var_count, var_primcount);
			SET_LASTCALL("glDrawArraysInstanced");
			break;
		}
		case OP_glDrawElementsInstanced: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_indices __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_indices(ptr + 8 + 4 + 4 + 4 + 4, size_indices);
			GLsizei var_primcount = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + size_indices);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_indices + 4, ptr + 8 + 4 + 4 + 4 + 4 + size_indices + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawElementsInstanced: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawElementsInstanced\n", err);
		#endif
			DEBUG("gles2(%p): glDrawElementsInstanced(0x%08x %d 0x%08x %p(%u) %d )\n", stream, var_mode, var_count, var_type, (const void*)(inptr_indices.get()), size_indices, var_primcount);
			this->glDrawElementsInstanced(var_mode, var_count, var_type, (const void*)(inptr_indices.get()), var_primcount);
			SET_LASTCALL("glDrawElementsInstanced");
			break;
		}
		case OP_glDrawElementsInstancedDataAEMU: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_indices __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_indices(ptr + 8 + 4 + 4 + 4 + 4, size_indices);
			GLsizei var_primcount = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + size_indices);
			GLsizei var_datalen = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + size_indices + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_indices + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + size_indices + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawElementsInstancedDataAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawElementsInstancedDataAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glDrawElementsInstancedDataAEMU(0x%08x %d 0x%08x %p(%u) %d %d )\n", stream, var_mode, var_count, var_type, (const void*)(inptr_indices.get()), size_indices, var_primcount, var_datalen);
			this->glDrawElementsInstancedDataAEMU(this, var_mode, var_count, var_type, (const void*)(inptr_indices.get()), var_primcount, var_datalen);
			SET_LASTCALL("glDrawElementsInstancedDataAEMU");
			break;
		}
		case OP_glDrawElementsInstancedOffsetAEMU: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_primcount = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawElementsInstancedOffsetAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawElementsInstancedOffsetAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glDrawElementsInstancedOffsetAEMU(0x%08x %d 0x%08x %u %d )\n", stream, var_mode, var_count, var_type, var_offset, var_primcount);
			this->glDrawElementsInstancedOffsetAEMU(this, var_mode, var_count, var_type, var_offset, var_primcount);
			SET_LASTCALL("glDrawElementsInstancedOffsetAEMU");
			break;
		}
		case OP_glDrawRangeElements: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_start = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLuint var_end = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			uint32_t size_indices __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_indices(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4, size_indices);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + size_indices, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + size_indices, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawRangeElements: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawRangeElements\n", err);
		#endif
			DEBUG("gles2(%p): glDrawRangeElements(0x%08x %u %u %d 0x%08x %p(%u) )\n", stream, var_mode, var_start, var_end, var_count, var_type, (const GLvoid*)(inptr_indices.get()), size_indices);
			this->glDrawRangeElements(var_mode, var_start, var_end, var_count, var_type, (const GLvoid*)(inptr_indices.get()));
			SET_LASTCALL("glDrawRangeElements");
			break;
		}
		case OP_glDrawRangeElementsDataAEMU: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_start = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLuint var_end = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			uint32_t size_indices __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_indices(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4, size_indices);
			GLsizei var_datalen = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + size_indices);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + size_indices + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + size_indices + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawRangeElementsDataAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawRangeElementsDataAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glDrawRangeElementsDataAEMU(0x%08x %u %u %d 0x%08x %p(%u) %d )\n", stream, var_mode, var_start, var_end, var_count, var_type, (const GLvoid*)(inptr_indices.get()), size_indices, var_datalen);
			this->glDrawRangeElementsDataAEMU(this, var_mode, var_start, var_end, var_count, var_type, (const GLvoid*)(inptr_indices.get()), var_datalen);
			SET_LASTCALL("glDrawRangeElementsDataAEMU");
			break;
		}
		case OP_glDrawRangeElementsOffsetAEMU: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_start = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLuint var_end = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawRangeElementsOffsetAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawRangeElementsOffsetAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glDrawRangeElementsOffsetAEMU(0x%08x %u %u %d 0x%08x %u )\n", stream, var_mode, var_start, var_end, var_count, var_type, var_offset);
			this->glDrawRangeElementsOffsetAEMU(this, var_mode, var_start, var_end, var_count, var_type, var_offset);
			SET_LASTCALL("glDrawRangeElementsOffsetAEMU");
			break;
		}
		case OP_glFenceSync: {
			GLenum var_condition = Unpack<GLenum,uint32_t>(ptr + 8);
			GLbitfield var_flags = Unpack<GLbitfield,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFenceSync: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLsync);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFenceSync\n", err);
		#endif
			DEBUG("gles2(%p): glFenceSync(0x%08x 0x%08x )\n", stream, var_condition, var_flags);
			*(GLsync *)(&tmpBuf[0]) = 			this->glFenceSync(var_condition, var_flags);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glFenceSync");
			break;
		}
		case OP_glClientWaitSync: {
			GLsync var_wait_on = Unpack<GLsync,uint64_t>(ptr + 8);
			GLbitfield var_flags = Unpack<GLbitfield,uint32_t>(ptr + 8 + 8);
			GLuint64 var_timeout = Unpack<GLuint64,uint64_t>(ptr + 8 + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8 + 4 + 8, ptr + 8 + 8 + 4 + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glClientWaitSync: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLenum);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glClientWaitSync\n", err);
		#endif
			DEBUG("gles2(%p): glClientWaitSync(%p 0x%08x 0x%016lx )\n", stream, var_wait_on, var_flags, var_timeout);
			*(GLenum *)(&tmpBuf[0]) = 			this->glClientWaitSync(var_wait_on, var_flags, var_timeout);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glClientWaitSync");
			break;
		}
		case OP_glWaitSync: {
			GLsync var_wait_on = Unpack<GLsync,uint64_t>(ptr + 8);
			GLbitfield var_flags = Unpack<GLbitfield,uint32_t>(ptr + 8 + 8);
			GLuint64 var_timeout = Unpack<GLuint64,uint64_t>(ptr + 8 + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8 + 4 + 8, ptr + 8 + 8 + 4 + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glWaitSync: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glWaitSync\n", err);
		#endif
			DEBUG("gles2(%p): glWaitSync(%p 0x%08x 0x%016lx )\n", stream, var_wait_on, var_flags, var_timeout);
			this->glWaitSync(var_wait_on, var_flags, var_timeout);
			SET_LASTCALL("glWaitSync");
			break;
		}
		case OP_glDeleteSync: {
			GLsync var_to_delete = Unpack<GLsync,uint64_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8, ptr + 8 + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteSync: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteSync\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteSync(%p )\n", stream, var_to_delete);
			this->glDeleteSync(var_to_delete);
			SET_LASTCALL("glDeleteSync");
			break;
		}
		case OP_glIsSync: {
			GLsync var_sync = Unpack<GLsync,uint64_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8, ptr + 8 + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsSync: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsSync\n", err);
		#endif
			DEBUG("gles2(%p): glIsSync(%p )\n", stream, var_sync);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsSync(var_sync);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsSync");
			break;
		}
		case OP_glGetSynciv: {
			GLsync var_sync = Unpack<GLsync,uint64_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 8);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 8 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 8 + 4 + 4);
			InputBuffer inptr_length(ptr + 8 + 8 + 4 + 4 + 4, size_length);
			uint32_t size_values __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 8 + 4 + 4 + 4 + size_length);
			InputBuffer inptr_values(ptr + 8 + 8 + 4 + 4 + 4 + size_length + 4, size_values);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8 + 4 + 4 + 4 + size_length + 4 + size_values, ptr + 8 + 8 + 4 + 4 + 4 + size_length + 4 + size_values, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetSynciv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetSynciv\n", err);
		#endif
			DEBUG("gles2(%p): glGetSynciv(%p 0x%08x %d %p(%u) %p(%u) )\n", stream, var_sync, var_pname, var_bufSize, (GLsizei*)(inptr_length.get()), size_length, (GLint*)(inptr_values.get()), size_values);
			this->glGetSynciv(var_sync, var_pname, var_bufSize, (GLsizei*)(inptr_length.get()), (GLint*)(inptr_values.get()));
			SET_LASTCALL("glGetSynciv");
			break;
		}
		case OP_glFenceSyncAEMU: {
			GLenum var_condition = Unpack<GLenum,uint32_t>(ptr + 8);
			GLbitfield var_flags = Unpack<GLbitfield,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFenceSyncAEMU: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(uint64_t);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFenceSyncAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glFenceSyncAEMU(0x%08x 0x%08x )\n", stream, var_condition, var_flags);
			*(uint64_t *)(&tmpBuf[0]) = 			this->glFenceSyncAEMU(this, var_condition, var_flags);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glFenceSyncAEMU");
			break;
		}
		case OP_glClientWaitSyncAEMU: {
			uint64_t var_wait_on = Unpack<uint64_t,uint64_t>(ptr + 8);
			GLbitfield var_flags = Unpack<GLbitfield,uint32_t>(ptr + 8 + 8);
			GLuint64 var_timeout = Unpack<GLuint64,uint64_t>(ptr + 8 + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8 + 4 + 8, ptr + 8 + 8 + 4 + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glClientWaitSyncAEMU: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLenum);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glClientWaitSyncAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glClientWaitSyncAEMU(0x%016lx 0x%08x 0x%016lx )\n", stream, var_wait_on, var_flags, var_timeout);
			*(GLenum *)(&tmpBuf[0]) = 			this->glClientWaitSyncAEMU(this, var_wait_on, var_flags, var_timeout);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glClientWaitSyncAEMU");
			break;
		}
		case OP_glWaitSyncAEMU: {
			uint64_t var_wait_on = Unpack<uint64_t,uint64_t>(ptr + 8);
			GLbitfield var_flags = Unpack<GLbitfield,uint32_t>(ptr + 8 + 8);
			GLuint64 var_timeout = Unpack<GLuint64,uint64_t>(ptr + 8 + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8 + 4 + 8, ptr + 8 + 8 + 4 + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glWaitSyncAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glWaitSyncAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glWaitSyncAEMU(0x%016lx 0x%08x 0x%016lx )\n", stream, var_wait_on, var_flags, var_timeout);
			this->glWaitSyncAEMU(this, var_wait_on, var_flags, var_timeout);
			SET_LASTCALL("glWaitSyncAEMU");
			break;
		}
		case OP_glDeleteSyncAEMU: {
			uint64_t var_to_delete = Unpack<uint64_t,uint64_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8, ptr + 8 + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteSyncAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteSyncAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteSyncAEMU(0x%016lx )\n", stream, var_to_delete);
			this->glDeleteSyncAEMU(this, var_to_delete);
			SET_LASTCALL("glDeleteSyncAEMU");
			break;
		}
		case OP_glIsSyncAEMU: {
			uint64_t var_sync = Unpack<uint64_t,uint64_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8, ptr + 8 + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsSyncAEMU: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsSyncAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glIsSyncAEMU(0x%016lx )\n", stream, var_sync);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsSyncAEMU(this, var_sync);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsSyncAEMU");
			break;
		}
		case OP_glGetSyncivAEMU: {
			uint64_t var_sync = Unpack<uint64_t,uint64_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 8);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 8 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 8 + 4 + 4);
			uint32_t size_values __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8 + 4 + 4 + 4 + 4, ptr + 8 + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetSyncivAEMU: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_values;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_values(&tmpBuf[0 + size_length], size_values);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetSyncivAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glGetSyncivAEMU(0x%016lx 0x%08x %d %p(%u) %p(%u) )\n", stream, var_sync, var_pname, var_bufSize, (GLsizei*)(outptr_length.get()), size_length, (GLint*)(outptr_values.get()), size_values);
			this->glGetSyncivAEMU(this, var_sync, var_pname, var_bufSize, (GLsizei*)(outptr_length.get()), (GLint*)(outptr_values.get()));
			outptr_length.flush();
			outptr_values.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetSyncivAEMU");
			break;
		}
		case OP_glDrawBuffers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_bufs __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_bufs(ptr + 8 + 4 + 4, size_bufs);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_bufs, ptr + 8 + 4 + 4 + size_bufs, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawBuffers: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawBuffers\n", err);
		#endif
			DEBUG("gles2(%p): glDrawBuffers(%d %p(%u) )\n", stream, var_n, (const GLenum*)(inptr_bufs.get()), size_bufs);
			this->glDrawBuffers(var_n, (const GLenum*)(inptr_bufs.get()));
			SET_LASTCALL("glDrawBuffers");
			break;
		}
		case OP_glReadBuffer: {
			GLenum var_src = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glReadBuffer: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glReadBuffer\n", err);
		#endif
			DEBUG("gles2(%p): glReadBuffer(0x%08x )\n", stream, var_src);
			this->glReadBuffer(var_src);
			SET_LASTCALL("glReadBuffer");
			break;
		}
		case OP_glBlitFramebuffer: {
			GLint var_srcX0 = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_srcY0 = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_srcX1 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_srcY1 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_dstX0 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_dstY0 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLint var_dstX1 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLint var_dstY1 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLbitfield var_mask = Unpack<GLbitfield,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_filter = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBlitFramebuffer: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBlitFramebuffer\n", err);
		#endif
			DEBUG("gles2(%p): glBlitFramebuffer(%d %d %d %d %d %d %d %d 0x%08x 0x%08x )\n", stream, var_srcX0, var_srcY0, var_srcX1, var_srcY1, var_dstX0, var_dstY0, var_dstX1, var_dstY1, var_mask, var_filter);
			this->glBlitFramebuffer(var_srcX0, var_srcY0, var_srcX1, var_srcY1, var_dstX0, var_dstY0, var_dstX1, var_dstY1, var_mask, var_filter);
			SET_LASTCALL("glBlitFramebuffer");
			break;
		}
		case OP_glInvalidateFramebuffer: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_numAttachments = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_attachments __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_attachments(ptr + 8 + 4 + 4 + 4, size_attachments);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_attachments, ptr + 8 + 4 + 4 + 4 + size_attachments, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glInvalidateFramebuffer: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glInvalidateFramebuffer\n", err);
		#endif
			DEBUG("gles2(%p): glInvalidateFramebuffer(0x%08x %d %p(%u) )\n", stream, var_target, var_numAttachments, (const GLenum*)(inptr_attachments.get()), size_attachments);
			this->glInvalidateFramebuffer(var_target, var_numAttachments, (const GLenum*)(inptr_attachments.get()));
			SET_LASTCALL("glInvalidateFramebuffer");
			break;
		}
		case OP_glInvalidateSubFramebuffer: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_numAttachments = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_attachments __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_attachments(ptr + 8 + 4 + 4 + 4, size_attachments);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_attachments);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_attachments + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_attachments + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_attachments + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_attachments + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + size_attachments + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glInvalidateSubFramebuffer: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glInvalidateSubFramebuffer\n", err);
		#endif
			DEBUG("gles2(%p): glInvalidateSubFramebuffer(0x%08x %d %p(%u) %d %d %d %d )\n", stream, var_target, var_numAttachments, (const GLenum*)(inptr_attachments.get()), size_attachments, var_x, var_y, var_width, var_height);
			this->glInvalidateSubFramebuffer(var_target, var_numAttachments, (const GLenum*)(inptr_attachments.get()), var_x, var_y, var_width, var_height);
			SET_LASTCALL("glInvalidateSubFramebuffer");
			break;
		}
		case OP_glFramebufferTextureLayer: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_attachment = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLuint var_texture = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_layer = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFramebufferTextureLayer: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFramebufferTextureLayer\n", err);
		#endif
			DEBUG("gles2(%p): glFramebufferTextureLayer(0x%08x 0x%08x %u %d %d )\n", stream, var_target, var_attachment, var_texture, var_level, var_layer);
			this->glFramebufferTextureLayer(var_target, var_attachment, var_texture, var_level, var_layer);
			SET_LASTCALL("glFramebufferTextureLayer");
			break;
		}
		case OP_glRenderbufferStorageMultisample: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_samples = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glRenderbufferStorageMultisample: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glRenderbufferStorageMultisample\n", err);
		#endif
			DEBUG("gles2(%p): glRenderbufferStorageMultisample(0x%08x %d 0x%08x %d %d )\n", stream, var_target, var_samples, var_internalformat, var_width, var_height);
			this->glRenderbufferStorageMultisample(var_target, var_samples, var_internalformat, var_width, var_height);
			SET_LASTCALL("glRenderbufferStorageMultisample");
			break;
		}
		case OP_glTexStorage2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_levels = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexStorage2D: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexStorage2D\n", err);
		#endif
			DEBUG("gles2(%p): glTexStorage2D(0x%08x %d 0x%08x %d %d )\n", stream, var_target, var_levels, var_internalformat, var_width, var_height);
			this->glTexStorage2D(var_target, var_levels, var_internalformat, var_width, var_height);
			SET_LASTCALL("glTexStorage2D");
			break;
		}
		case OP_glGetInternalformativ: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetInternalformativ: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetInternalformativ\n", err);
		#endif
			DEBUG("gles2(%p): glGetInternalformativ(0x%08x 0x%08x 0x%08x %d %p(%u) )\n", stream, var_target, var_internalformat, var_pname, var_bufSize, (GLint*)(outptr_params.get()), size_params);
			this->glGetInternalformativ(var_target, var_internalformat, var_pname, var_bufSize, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetInternalformativ");
			break;
		}
		case OP_glBeginTransformFeedback: {
			GLenum var_primitiveMode = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBeginTransformFeedback: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBeginTransformFeedback\n", err);
		#endif
			DEBUG("gles2(%p): glBeginTransformFeedback(0x%08x )\n", stream, var_primitiveMode);
			this->glBeginTransformFeedback(var_primitiveMode);
			SET_LASTCALL("glBeginTransformFeedback");
			break;
		}
		case OP_glEndTransformFeedback: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8, ptr + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glEndTransformFeedback: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glEndTransformFeedback\n", err);
		#endif
			DEBUG("gles2(%p): glEndTransformFeedback()\n", stream);
			this->glEndTransformFeedback();
			SET_LASTCALL("glEndTransformFeedback");
			break;
		}
		case OP_glGenTransformFeedbacks: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_ids __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGenTransformFeedbacks: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_ids;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_ids(&tmpBuf[0], size_ids);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGenTransformFeedbacks\n", err);
		#endif
			DEBUG("gles2(%p): glGenTransformFeedbacks(%d %p(%u) )\n", stream, var_n, (GLuint*)(outptr_ids.get()), size_ids);
			this->glGenTransformFeedbacks(var_n, (GLuint*)(outptr_ids.get()));
			outptr_ids.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenTransformFeedbacks");
			break;
		}
		case OP_glDeleteTransformFeedbacks: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_ids __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_ids(ptr + 8 + 4 + 4, size_ids);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_ids, ptr + 8 + 4 + 4 + size_ids, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteTransformFeedbacks: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteTransformFeedbacks\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteTransformFeedbacks(%d %p(%u) )\n", stream, var_n, (const GLuint*)(inptr_ids.get()), size_ids);
			this->glDeleteTransformFeedbacks(var_n, (const GLuint*)(inptr_ids.get()));
			SET_LASTCALL("glDeleteTransformFeedbacks");
			break;
		}
		case OP_glBindTransformFeedback: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_id = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBindTransformFeedback: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBindTransformFeedback\n", err);
		#endif
			DEBUG("gles2(%p): glBindTransformFeedback(0x%08x %u )\n", stream, var_target, var_id);
			this->glBindTransformFeedback(var_target, var_id);
			SET_LASTCALL("glBindTransformFeedback");
			break;
		}
		case OP_glPauseTransformFeedback: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8, ptr + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glPauseTransformFeedback: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glPauseTransformFeedback\n", err);
		#endif
			DEBUG("gles2(%p): glPauseTransformFeedback()\n", stream);
			this->glPauseTransformFeedback();
			SET_LASTCALL("glPauseTransformFeedback");
			break;
		}
		case OP_glResumeTransformFeedback: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8, ptr + 8, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glResumeTransformFeedback: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glResumeTransformFeedback\n", err);
		#endif
			DEBUG("gles2(%p): glResumeTransformFeedback()\n", stream);
			this->glResumeTransformFeedback();
			SET_LASTCALL("glResumeTransformFeedback");
			break;
		}
		case OP_glIsTransformFeedback: {
			GLuint var_id = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsTransformFeedback: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsTransformFeedback\n", err);
		#endif
			DEBUG("gles2(%p): glIsTransformFeedback(%u )\n", stream, var_id);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsTransformFeedback(var_id);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsTransformFeedback");
			break;
		}
		case OP_glTransformFeedbackVaryings: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_varyings __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_varyings(ptr + 8 + 4 + 4 + 4, size_varyings);
			GLenum var_bufferMode = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_varyings);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_varyings + 4, ptr + 8 + 4 + 4 + 4 + size_varyings + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTransformFeedbackVaryings: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTransformFeedbackVaryings\n", err);
		#endif
			DEBUG("gles2(%p): glTransformFeedbackVaryings(%u %d %p(%u) 0x%08x )\n", stream, var_program, var_count, (const char**)(inptr_varyings.get()), size_varyings, var_bufferMode);
			this->glTransformFeedbackVaryings(var_program, var_count, (const char**)(inptr_varyings.get()), var_bufferMode);
			SET_LASTCALL("glTransformFeedbackVaryings");
			break;
		}
		case OP_glTransformFeedbackVaryingsAEMU: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_packedVaryings __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_packedVaryings(ptr + 8 + 4 + 4 + 4, size_packedVaryings);
			GLuint var_packedVaryingsLen = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_packedVaryings);
			GLenum var_bufferMode = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_packedVaryings + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_packedVaryings + 4 + 4, ptr + 8 + 4 + 4 + 4 + size_packedVaryings + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTransformFeedbackVaryingsAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTransformFeedbackVaryingsAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glTransformFeedbackVaryingsAEMU(%u %d %p(%u) %u 0x%08x )\n", stream, var_program, var_count, (const char*)(inptr_packedVaryings.get()), size_packedVaryings, var_packedVaryingsLen, var_bufferMode);
			this->glTransformFeedbackVaryingsAEMU(this, var_program, var_count, (const char*)(inptr_packedVaryings.get()), var_packedVaryingsLen, var_bufferMode);
			SET_LASTCALL("glTransformFeedbackVaryingsAEMU");
			break;
		}
		case OP_glGetTransformFeedbackVarying: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_size __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			uint32_t size_type __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_name __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetTransformFeedbackVarying: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_size;
			totalTmpSize += size_type;
			totalTmpSize += size_name;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_size(&tmpBuf[0 + size_length], size_size);
			OutputBuffer outptr_type(&tmpBuf[0 + size_length + size_size], size_type);
			OutputBuffer outptr_name(&tmpBuf[0 + size_length + size_size + size_type], size_name);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetTransformFeedbackVarying\n", err);
		#endif
			DEBUG("gles2(%p): glGetTransformFeedbackVarying(%u %u %d %p(%u) %p(%u) %p(%u) %p(%u) )\n", stream, var_program, var_index, var_bufSize, (GLsizei*)(outptr_length.get()), size_length, (GLsizei*)(outptr_size.get()), size_size, (GLenum*)(outptr_type.get()), size_type, (char*)(outptr_name.get()), size_name);
			this->glGetTransformFeedbackVarying(var_program, var_index, var_bufSize, size_length == 0 ? nullptr : (GLsizei*)(outptr_length.get()), (GLsizei*)(outptr_size.get()), size_type == 0 ? nullptr : (GLenum*)(outptr_type.get()), size_name == 0 ? nullptr : (char*)(outptr_name.get()));
			outptr_length.flush();
			outptr_size.flush();
			outptr_type.flush();
			outptr_name.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetTransformFeedbackVarying");
			break;
		}
		case OP_glGenSamplers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_samplers __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGenSamplers: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_samplers;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_samplers(&tmpBuf[0], size_samplers);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGenSamplers\n", err);
		#endif
			DEBUG("gles2(%p): glGenSamplers(%d %p(%u) )\n", stream, var_n, (GLuint*)(outptr_samplers.get()), size_samplers);
			this->glGenSamplers(var_n, (GLuint*)(outptr_samplers.get()));
			outptr_samplers.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenSamplers");
			break;
		}
		case OP_glDeleteSamplers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_samplers __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_samplers(ptr + 8 + 4 + 4, size_samplers);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_samplers, ptr + 8 + 4 + 4 + size_samplers, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteSamplers: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteSamplers\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteSamplers(%d %p(%u) )\n", stream, var_n, (const GLuint*)(inptr_samplers.get()), size_samplers);
			this->glDeleteSamplers(var_n, (const GLuint*)(inptr_samplers.get()));
			SET_LASTCALL("glDeleteSamplers");
			break;
		}
		case OP_glBindSampler: {
			GLuint var_unit = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_sampler = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBindSampler: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBindSampler\n", err);
		#endif
			DEBUG("gles2(%p): glBindSampler(%u %u )\n", stream, var_unit, var_sampler);
			this->glBindSampler(var_unit, var_sampler);
			SET_LASTCALL("glBindSampler");
			break;
		}
		case OP_glSamplerParameterf: {
			GLuint var_sampler = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLfloat var_param = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glSamplerParameterf: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glSamplerParameterf\n", err);
		#endif
			DEBUG("gles2(%p): glSamplerParameterf(%u 0x%08x %f )\n", stream, var_sampler, var_pname, var_param);
			this->glSamplerParameterf(var_sampler, var_pname, var_param);
			SET_LASTCALL("glSamplerParameterf");
			break;
		}
		case OP_glSamplerParameteri: {
			GLuint var_sampler = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLint var_param = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glSamplerParameteri: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glSamplerParameteri\n", err);
		#endif
			DEBUG("gles2(%p): glSamplerParameteri(%u 0x%08x %d )\n", stream, var_sampler, var_pname, var_param);
			this->glSamplerParameteri(var_sampler, var_pname, var_param);
			SET_LASTCALL("glSamplerParameteri");
			break;
		}
		case OP_glSamplerParameterfv: {
			GLuint var_sampler = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_params(ptr + 8 + 4 + 4 + 4, size_params);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_params, ptr + 8 + 4 + 4 + 4 + size_params, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glSamplerParameterfv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glSamplerParameterfv\n", err);
		#endif
			DEBUG("gles2(%p): glSamplerParameterfv(%u 0x%08x %p(%u) )\n", stream, var_sampler, var_pname, (const GLfloat*)(inptr_params.get()), size_params);
			this->glSamplerParameterfv(var_sampler, var_pname, (const GLfloat*)(inptr_params.get()));
			SET_LASTCALL("glSamplerParameterfv");
			break;
		}
		case OP_glSamplerParameteriv: {
			GLuint var_sampler = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_params(ptr + 8 + 4 + 4 + 4, size_params);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_params, ptr + 8 + 4 + 4 + 4 + size_params, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glSamplerParameteriv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glSamplerParameteriv\n", err);
		#endif
			DEBUG("gles2(%p): glSamplerParameteriv(%u 0x%08x %p(%u) )\n", stream, var_sampler, var_pname, (const GLint*)(inptr_params.get()), size_params);
			this->glSamplerParameteriv(var_sampler, var_pname, (const GLint*)(inptr_params.get()));
			SET_LASTCALL("glSamplerParameteriv");
			break;
		}
		case OP_glGetSamplerParameterfv: {
			GLuint var_sampler = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetSamplerParameterfv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetSamplerParameterfv\n", err);
		#endif
			DEBUG("gles2(%p): glGetSamplerParameterfv(%u 0x%08x %p(%u) )\n", stream, var_sampler, var_pname, (GLfloat*)(outptr_params.get()), size_params);
			this->glGetSamplerParameterfv(var_sampler, var_pname, (GLfloat*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetSamplerParameterfv");
			break;
		}
		case OP_glGetSamplerParameteriv: {
			GLuint var_sampler = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetSamplerParameteriv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetSamplerParameteriv\n", err);
		#endif
			DEBUG("gles2(%p): glGetSamplerParameteriv(%u 0x%08x %p(%u) )\n", stream, var_sampler, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetSamplerParameteriv(var_sampler, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetSamplerParameteriv");
			break;
		}
		case OP_glIsSampler: {
			GLuint var_sampler = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsSampler: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsSampler\n", err);
		#endif
			DEBUG("gles2(%p): glIsSampler(%u )\n", stream, var_sampler);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsSampler(var_sampler);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsSampler");
			break;
		}
		case OP_glGenQueries: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_queries __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGenQueries: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_queries;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_queries(&tmpBuf[0], size_queries);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGenQueries\n", err);
		#endif
			DEBUG("gles2(%p): glGenQueries(%d %p(%u) )\n", stream, var_n, (GLuint*)(outptr_queries.get()), size_queries);
			this->glGenQueries(var_n, (GLuint*)(outptr_queries.get()));
			outptr_queries.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenQueries");
			break;
		}
		case OP_glDeleteQueries: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_queries __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_queries(ptr + 8 + 4 + 4, size_queries);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_queries, ptr + 8 + 4 + 4 + size_queries, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteQueries: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteQueries\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteQueries(%d %p(%u) )\n", stream, var_n, (const GLuint*)(inptr_queries.get()), size_queries);
			this->glDeleteQueries(var_n, (const GLuint*)(inptr_queries.get()));
			SET_LASTCALL("glDeleteQueries");
			break;
		}
		case OP_glBeginQuery: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_query = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBeginQuery: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBeginQuery\n", err);
		#endif
			DEBUG("gles2(%p): glBeginQuery(0x%08x %u )\n", stream, var_target, var_query);
			this->glBeginQuery(var_target, var_query);
			SET_LASTCALL("glBeginQuery");
			break;
		}
		case OP_glEndQuery: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glEndQuery: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glEndQuery\n", err);
		#endif
			DEBUG("gles2(%p): glEndQuery(0x%08x )\n", stream, var_target);
			this->glEndQuery(var_target);
			SET_LASTCALL("glEndQuery");
			break;
		}
		case OP_glGetQueryiv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetQueryiv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetQueryiv\n", err);
		#endif
			DEBUG("gles2(%p): glGetQueryiv(0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetQueryiv(var_target, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetQueryiv");
			break;
		}
		case OP_glGetQueryObjectuiv: {
			GLuint var_query = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetQueryObjectuiv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetQueryObjectuiv\n", err);
		#endif
			DEBUG("gles2(%p): glGetQueryObjectuiv(%u 0x%08x %p(%u) )\n", stream, var_query, var_pname, (GLuint*)(outptr_params.get()), size_params);
			this->glGetQueryObjectuiv(var_query, var_pname, (GLuint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetQueryObjectuiv");
			break;
		}
		case OP_glIsQuery: {
			GLuint var_query = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsQuery: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsQuery\n", err);
		#endif
			DEBUG("gles2(%p): glIsQuery(%u )\n", stream, var_query);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsQuery(var_query);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsQuery");
			break;
		}
		case OP_glProgramParameteri: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLint var_value = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramParameteri: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramParameteri\n", err);
		#endif
			DEBUG("gles2(%p): glProgramParameteri(%u 0x%08x %d )\n", stream, var_program, var_pname, var_value);
			this->glProgramParameteri(var_program, var_pname, var_value);
			SET_LASTCALL("glProgramParameteri");
			break;
		}
		case OP_glProgramBinary: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_binaryFormat = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_binary __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_binary(ptr + 8 + 4 + 4 + 4, size_binary);
			GLsizei var_length = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_binary);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_binary + 4, ptr + 8 + 4 + 4 + 4 + size_binary + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramBinary: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramBinary\n", err);
		#endif
			DEBUG("gles2(%p): glProgramBinary(%u 0x%08x %p(%u) %d )\n", stream, var_program, var_binaryFormat, (const void*)(inptr_binary.get()), size_binary, var_length);
			this->glProgramBinary(var_program, var_binaryFormat, (const void*)(inptr_binary.get()), var_length);
			SET_LASTCALL("glProgramBinary");
			break;
		}
		case OP_glGetProgramBinary: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_binaryFormat __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_binary __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetProgramBinary: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_binaryFormat;
			totalTmpSize += size_binary;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_binaryFormat(&tmpBuf[0 + size_length], size_binaryFormat);
			OutputBuffer outptr_binary(&tmpBuf[0 + size_length + size_binaryFormat], size_binary);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetProgramBinary\n", err);
		#endif
			DEBUG("gles2(%p): glGetProgramBinary(%u %d %p(%u) %p(%u) %p(%u) )\n", stream, var_program, var_bufSize, (GLsizei*)(outptr_length.get()), size_length, (GLenum*)(outptr_binaryFormat.get()), size_binaryFormat, (void*)(outptr_binary.get()), size_binary);
			this->glGetProgramBinary(var_program, var_bufSize, (GLsizei*)(outptr_length.get()), (GLenum*)(outptr_binaryFormat.get()), (void*)(outptr_binary.get()));
			outptr_length.flush();
			outptr_binaryFormat.flush();
			outptr_binary.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetProgramBinary");
			break;
		}
		case OP_glGetFragDataLocation: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_name __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_name(ptr + 8 + 4 + 4, size_name);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_name, ptr + 8 + 4 + 4 + size_name, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetFragDataLocation: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetFragDataLocation\n", err);
		#endif
			DEBUG("gles2(%p): glGetFragDataLocation(%u %p(%u) )\n", stream, var_program, (const char*)(inptr_name.get()), size_name);
			*(GLint *)(&tmpBuf[0]) = 			this->glGetFragDataLocation(var_program, (const char*)(inptr_name.get()));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetFragDataLocation");
			break;
		}
		case OP_glGetInteger64v: {
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetInteger64v: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_data;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_data(&tmpBuf[0], size_data);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetInteger64v\n", err);
		#endif
			DEBUG("gles2(%p): glGetInteger64v(0x%08x %p(%u) )\n", stream, var_pname, (GLint64*)(outptr_data.get()), size_data);
			this->glGetInteger64v(var_pname, (GLint64*)(outptr_data.get()));
			outptr_data.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetInteger64v");
			break;
		}
		case OP_glGetIntegeri_v: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetIntegeri_v: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_data;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_data(&tmpBuf[0], size_data);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetIntegeri_v\n", err);
		#endif
			DEBUG("gles2(%p): glGetIntegeri_v(0x%08x %u %p(%u) )\n", stream, var_target, var_index, (GLint*)(outptr_data.get()), size_data);
			this->glGetIntegeri_v(var_target, var_index, (GLint*)(outptr_data.get()));
			outptr_data.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetIntegeri_v");
			break;
		}
		case OP_glGetInteger64i_v: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetInteger64i_v: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_data;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_data(&tmpBuf[0], size_data);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetInteger64i_v\n", err);
		#endif
			DEBUG("gles2(%p): glGetInteger64i_v(0x%08x %u %p(%u) )\n", stream, var_target, var_index, (GLint64*)(outptr_data.get()), size_data);
			this->glGetInteger64i_v(var_target, var_index, (GLint64*)(outptr_data.get()));
			outptr_data.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetInteger64i_v");
			break;
		}
		case OP_glTexImage3D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_internalFormat = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexImage3D: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexImage3D\n", err);
		#endif
			DEBUG("gles2(%p): glTexImage3D(0x%08x %d %d %d %d %d %d 0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_level, var_internalFormat, var_width, var_height, var_depth, var_border, var_format, var_type, (const GLvoid*)(inptr_data.get()), size_data);
			this->glTexImage3D(var_target, var_level, var_internalFormat, var_width, var_height, var_depth, var_border, var_format, var_type, size_data == 0 ? nullptr : (const GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glTexImage3D");
			break;
		}
		case OP_glTexImage3DOffsetAEMU: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_internalFormat = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexImage3DOffsetAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexImage3DOffsetAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glTexImage3DOffsetAEMU(0x%08x %d %d %d %d %d %d 0x%08x 0x%08x %u )\n", stream, var_target, var_level, var_internalFormat, var_width, var_height, var_depth, var_border, var_format, var_type, var_offset);
			this->glTexImage3DOffsetAEMU(this, var_target, var_level, var_internalFormat, var_width, var_height, var_depth, var_border, var_format, var_type, var_offset);
			SET_LASTCALL("glTexImage3DOffsetAEMU");
			break;
		}
		case OP_glTexStorage3D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_levels = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexStorage3D: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexStorage3D\n", err);
		#endif
			DEBUG("gles2(%p): glTexStorage3D(0x%08x %d 0x%08x %d %d %d )\n", stream, var_target, var_levels, var_internalformat, var_width, var_height, var_depth);
			this->glTexStorage3D(var_target, var_levels, var_internalformat, var_width, var_height, var_depth);
			SET_LASTCALL("glTexStorage3D");
			break;
		}
		case OP_glTexSubImage3D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexSubImage3D: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexSubImage3D\n", err);
		#endif
			DEBUG("gles2(%p): glTexSubImage3D(0x%08x %d %d %d %d %d %d %d 0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_type, (const GLvoid*)(inptr_data.get()), size_data);
			this->glTexSubImage3D(var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_type, size_data == 0 ? nullptr : (const GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glTexSubImage3D");
			break;
		}
		case OP_glTexSubImage3DOffsetAEMU: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexSubImage3DOffsetAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexSubImage3DOffsetAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glTexSubImage3DOffsetAEMU(0x%08x %d %d %d %d %d %d %d 0x%08x 0x%08x %u )\n", stream, var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_type, var_offset);
			this->glTexSubImage3DOffsetAEMU(this, var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_type, var_offset);
			SET_LASTCALL("glTexSubImage3DOffsetAEMU");
			break;
		}
		case OP_glCompressedTexImage3D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_imageSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCompressedTexImage3D: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCompressedTexImage3D\n", err);
		#endif
			DEBUG("gles2(%p): glCompressedTexImage3D(0x%08x %d 0x%08x %d %d %d %d %d %p(%u) )\n", stream, var_target, var_level, var_internalformat, var_width, var_height, var_depth, var_border, var_imageSize, (const GLvoid*)(inptr_data.get()), size_data);
			this->glCompressedTexImage3D(var_target, var_level, var_internalformat, var_width, var_height, var_depth, var_border, var_imageSize, size_data == 0 ? nullptr : (const GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glCompressedTexImage3D");
			break;
		}
		case OP_glCompressedTexImage3DOffsetAEMU: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_imageSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCompressedTexImage3DOffsetAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCompressedTexImage3DOffsetAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glCompressedTexImage3DOffsetAEMU(0x%08x %d 0x%08x %d %d %d %d %d %u )\n", stream, var_target, var_level, var_internalformat, var_width, var_height, var_depth, var_border, var_imageSize, var_offset);
			this->glCompressedTexImage3DOffsetAEMU(this, var_target, var_level, var_internalformat, var_width, var_height, var_depth, var_border, var_imageSize, var_offset);
			SET_LASTCALL("glCompressedTexImage3DOffsetAEMU");
			break;
		}
		case OP_glCompressedTexSubImage3D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_imageSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCompressedTexSubImage3D: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCompressedTexSubImage3D\n", err);
		#endif
			DEBUG("gles2(%p): glCompressedTexSubImage3D(0x%08x %d %d %d %d %d %d %d 0x%08x %d %p(%u) )\n", stream, var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_imageSize, (const GLvoid*)(inptr_data.get()), size_data);
			this->glCompressedTexSubImage3D(var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_imageSize, size_data == 0 ? nullptr : (const GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glCompressedTexSubImage3D");
			break;
		}
		case OP_glCompressedTexSubImage3DOffsetAEMU: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_imageSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLuint var_data = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCompressedTexSubImage3DOffsetAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCompressedTexSubImage3DOffsetAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glCompressedTexSubImage3DOffsetAEMU(0x%08x %d %d %d %d %d %d %d 0x%08x %d %u )\n", stream, var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_imageSize, var_data);
			this->glCompressedTexSubImage3DOffsetAEMU(this, var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_imageSize, var_data);
			SET_LASTCALL("glCompressedTexSubImage3DOffsetAEMU");
			break;
		}
		case OP_glCopyTexSubImage3D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCopyTexSubImage3D: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCopyTexSubImage3D\n", err);
		#endif
			DEBUG("gles2(%p): glCopyTexSubImage3D(0x%08x %d %d %d %d %d %d %d %d )\n", stream, var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_x, var_y, var_width, var_height);
			this->glCopyTexSubImage3D(var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_x, var_y, var_width, var_height);
			SET_LASTCALL("glCopyTexSubImage3D");
			break;
		}
		case OP_glGetStringi: {
			GLenum var_name = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetStringi: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetStringi\n", err);
		#endif
			DEBUG("gles2(%p): glGetStringi(0x%08x %u )\n", stream, var_name, var_index);
			this->glGetStringi(var_name, var_index);
			SET_LASTCALL("glGetStringi");
			break;
		}
		case OP_glGetBooleani_v: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			uint32_t size_data __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetBooleani_v: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_data;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_data(&tmpBuf[0], size_data);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetBooleani_v\n", err);
		#endif
			DEBUG("gles2(%p): glGetBooleani_v(0x%08x %u %p(%u) )\n", stream, var_target, var_index, (GLboolean*)(outptr_data.get()), size_data);
			this->glGetBooleani_v(var_target, var_index, (GLboolean*)(outptr_data.get()));
			outptr_data.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetBooleani_v");
			break;
		}
		case OP_glMemoryBarrier: {
			GLbitfield var_barriers = Unpack<GLbitfield,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glMemoryBarrier: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glMemoryBarrier\n", err);
		#endif
			DEBUG("gles2(%p): glMemoryBarrier(0x%08x )\n", stream, var_barriers);
			this->glMemoryBarrier(var_barriers);
			SET_LASTCALL("glMemoryBarrier");
			break;
		}
		case OP_glMemoryBarrierByRegion: {
			GLbitfield var_barriers = Unpack<GLbitfield,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glMemoryBarrierByRegion: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glMemoryBarrierByRegion\n", err);
		#endif
			DEBUG("gles2(%p): glMemoryBarrierByRegion(0x%08x )\n", stream, var_barriers);
			this->glMemoryBarrierByRegion(var_barriers);
			SET_LASTCALL("glMemoryBarrierByRegion");
			break;
		}
		case OP_glGenProgramPipelines: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_pipelines __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGenProgramPipelines: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_pipelines;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_pipelines(&tmpBuf[0], size_pipelines);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGenProgramPipelines\n", err);
		#endif
			DEBUG("gles2(%p): glGenProgramPipelines(%d %p(%u) )\n", stream, var_n, (GLuint*)(outptr_pipelines.get()), size_pipelines);
			this->glGenProgramPipelines(var_n, (GLuint*)(outptr_pipelines.get()));
			outptr_pipelines.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenProgramPipelines");
			break;
		}
		case OP_glDeleteProgramPipelines: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_pipelines __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_pipelines(ptr + 8 + 4 + 4, size_pipelines);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_pipelines, ptr + 8 + 4 + 4 + size_pipelines, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDeleteProgramPipelines: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDeleteProgramPipelines\n", err);
		#endif
			DEBUG("gles2(%p): glDeleteProgramPipelines(%d %p(%u) )\n", stream, var_n, (const GLuint*)(inptr_pipelines.get()), size_pipelines);
			this->glDeleteProgramPipelines(var_n, (const GLuint*)(inptr_pipelines.get()));
			SET_LASTCALL("glDeleteProgramPipelines");
			break;
		}
		case OP_glBindProgramPipeline: {
			GLuint var_pipeline = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBindProgramPipeline: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBindProgramPipeline\n", err);
		#endif
			DEBUG("gles2(%p): glBindProgramPipeline(%u )\n", stream, var_pipeline);
			this->glBindProgramPipeline(var_pipeline);
			SET_LASTCALL("glBindProgramPipeline");
			break;
		}
		case OP_glGetProgramPipelineiv: {
			GLuint var_pipeline = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetProgramPipelineiv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetProgramPipelineiv\n", err);
		#endif
			DEBUG("gles2(%p): glGetProgramPipelineiv(%u 0x%08x %p(%u) )\n", stream, var_pipeline, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetProgramPipelineiv(var_pipeline, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetProgramPipelineiv");
			break;
		}
		case OP_glGetProgramPipelineInfoLog: {
			GLuint var_pipeline = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_infoLog __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetProgramPipelineInfoLog: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_infoLog;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_infoLog(&tmpBuf[0 + size_length], size_infoLog);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetProgramPipelineInfoLog\n", err);
		#endif
			DEBUG("gles2(%p): glGetProgramPipelineInfoLog(%u %d %p(%u) %p(%u) )\n", stream, var_pipeline, var_bufSize, (GLsizei*)(outptr_length.get()), size_length, (GLchar*)(outptr_infoLog.get()), size_infoLog);
			this->glGetProgramPipelineInfoLog(var_pipeline, var_bufSize, size_length == 0 ? nullptr : (GLsizei*)(outptr_length.get()), (GLchar*)(outptr_infoLog.get()));
			outptr_length.flush();
			outptr_infoLog.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetProgramPipelineInfoLog");
			break;
		}
		case OP_glValidateProgramPipeline: {
			GLuint var_pipeline = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glValidateProgramPipeline: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glValidateProgramPipeline\n", err);
		#endif
			DEBUG("gles2(%p): glValidateProgramPipeline(%u )\n", stream, var_pipeline);
			this->glValidateProgramPipeline(var_pipeline);
			SET_LASTCALL("glValidateProgramPipeline");
			break;
		}
		case OP_glIsProgramPipeline: {
			GLuint var_pipeline = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glIsProgramPipeline: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glIsProgramPipeline\n", err);
		#endif
			DEBUG("gles2(%p): glIsProgramPipeline(%u )\n", stream, var_pipeline);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsProgramPipeline(var_pipeline);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsProgramPipeline");
			break;
		}
		case OP_glUseProgramStages: {
			GLuint var_pipeline = Unpack<GLuint,uint32_t>(ptr + 8);
			GLbitfield var_stages = Unpack<GLbitfield,uint32_t>(ptr + 8 + 4);
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glUseProgramStages: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glUseProgramStages\n", err);
		#endif
			DEBUG("gles2(%p): glUseProgramStages(%u 0x%08x %u )\n", stream, var_pipeline, var_stages, var_program);
			this->glUseProgramStages(var_pipeline, var_stages, var_program);
			SET_LASTCALL("glUseProgramStages");
			break;
		}
		case OP_glCreateShaderProgramv: {
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_strings __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_strings(ptr + 8 + 4 + 4 + 4, size_strings);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_strings, ptr + 8 + 4 + 4 + 4 + size_strings, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCreateShaderProgramv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLuint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCreateShaderProgramv\n", err);
		#endif
			DEBUG("gles2(%p): glCreateShaderProgramv(0x%08x %d %p(%u) )\n", stream, var_type, var_count, (const char**)(inptr_strings.get()), size_strings);
			*(GLuint *)(&tmpBuf[0]) = 			this->glCreateShaderProgramv(var_type, var_count, (const char**)(inptr_strings.get()));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glCreateShaderProgramv");
			break;
		}
		case OP_glCreateShaderProgramvAEMU: {
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_packedStrings __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_packedStrings(ptr + 8 + 4 + 4 + 4, size_packedStrings);
			GLuint var_packedLen = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_packedStrings);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_packedStrings + 4, ptr + 8 + 4 + 4 + 4 + size_packedStrings + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glCreateShaderProgramvAEMU: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLuint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glCreateShaderProgramvAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glCreateShaderProgramvAEMU(0x%08x %d %p(%u) %u )\n", stream, var_type, var_count, (const char*)(inptr_packedStrings.get()), size_packedStrings, var_packedLen);
			*(GLuint *)(&tmpBuf[0]) = 			this->glCreateShaderProgramvAEMU(this, var_type, var_count, (const char*)(inptr_packedStrings.get()), var_packedLen);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glCreateShaderProgramvAEMU");
			break;
		}
		case OP_glProgramUniform1f: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLfloat var_v0 = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform1f: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform1f\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform1f(%u %d %f )\n", stream, var_program, var_location, var_v0);
			this->glProgramUniform1f(var_program, var_location, var_v0);
			SET_LASTCALL("glProgramUniform1f");
			break;
		}
		case OP_glProgramUniform2f: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLfloat var_v0 = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			GLfloat var_v1 = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform2f: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform2f\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform2f(%u %d %f %f )\n", stream, var_program, var_location, var_v0, var_v1);
			this->glProgramUniform2f(var_program, var_location, var_v0, var_v1);
			SET_LASTCALL("glProgramUniform2f");
			break;
		}
		case OP_glProgramUniform3f: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLfloat var_v0 = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			GLfloat var_v1 = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLfloat var_v2 = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform3f: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform3f\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform3f(%u %d %f %f %f )\n", stream, var_program, var_location, var_v0, var_v1, var_v2);
			this->glProgramUniform3f(var_program, var_location, var_v0, var_v1, var_v2);
			SET_LASTCALL("glProgramUniform3f");
			break;
		}
		case OP_glProgramUniform4f: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLfloat var_v0 = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			GLfloat var_v1 = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLfloat var_v2 = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLfloat var_v3 = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform4f: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform4f\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform4f(%u %d %f %f %f %f )\n", stream, var_program, var_location, var_v0, var_v1, var_v2, var_v3);
			this->glProgramUniform4f(var_program, var_location, var_v0, var_v1, var_v2, var_v3);
			SET_LASTCALL("glProgramUniform4f");
			break;
		}
		case OP_glProgramUniform1i: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_v0 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform1i: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform1i\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform1i(%u %d %d )\n", stream, var_program, var_location, var_v0);
			this->glProgramUniform1i(var_program, var_location, var_v0);
			SET_LASTCALL("glProgramUniform1i");
			break;
		}
		case OP_glProgramUniform2i: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_v0 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_v1 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform2i: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform2i\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform2i(%u %d %d %d )\n", stream, var_program, var_location, var_v0, var_v1);
			this->glProgramUniform2i(var_program, var_location, var_v0, var_v1);
			SET_LASTCALL("glProgramUniform2i");
			break;
		}
		case OP_glProgramUniform3i: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_v0 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_v1 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_v2 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform3i: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform3i\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform3i(%u %d %d %d %d )\n", stream, var_program, var_location, var_v0, var_v1, var_v2);
			this->glProgramUniform3i(var_program, var_location, var_v0, var_v1, var_v2);
			SET_LASTCALL("glProgramUniform3i");
			break;
		}
		case OP_glProgramUniform4i: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_v0 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_v1 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_v2 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_v3 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform4i: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform4i\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform4i(%u %d %d %d %d %d )\n", stream, var_program, var_location, var_v0, var_v1, var_v2, var_v3);
			this->glProgramUniform4i(var_program, var_location, var_v0, var_v1, var_v2, var_v3);
			SET_LASTCALL("glProgramUniform4i");
			break;
		}
		case OP_glProgramUniform1ui: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLuint var_v0 = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform1ui: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform1ui\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform1ui(%u %d %u )\n", stream, var_program, var_location, var_v0);
			this->glProgramUniform1ui(var_program, var_location, var_v0);
			SET_LASTCALL("glProgramUniform1ui");
			break;
		}
		case OP_glProgramUniform2ui: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_v0 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_v1 = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform2ui: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform2ui\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform2ui(%u %d %d %u )\n", stream, var_program, var_location, var_v0, var_v1);
			this->glProgramUniform2ui(var_program, var_location, var_v0, var_v1);
			SET_LASTCALL("glProgramUniform2ui");
			break;
		}
		case OP_glProgramUniform3ui: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_v0 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_v1 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLuint var_v2 = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform3ui: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform3ui\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform3ui(%u %d %d %d %u )\n", stream, var_program, var_location, var_v0, var_v1, var_v2);
			this->glProgramUniform3ui(var_program, var_location, var_v0, var_v1, var_v2);
			SET_LASTCALL("glProgramUniform3ui");
			break;
		}
		case OP_glProgramUniform4ui: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_v0 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_v1 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_v2 = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLuint var_v3 = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform4ui: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform4ui\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform4ui(%u %d %d %d %d %u )\n", stream, var_program, var_location, var_v0, var_v1, var_v2, var_v3);
			this->glProgramUniform4ui(var_program, var_location, var_v0, var_v1, var_v2, var_v3);
			SET_LASTCALL("glProgramUniform4ui");
			break;
		}
		case OP_glProgramUniform1fv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform1fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform1fv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform1fv(%u %d %d %p(%u) )\n", stream, var_program, var_location, var_count, (const GLfloat*)(inptr_value.get()), size_value);
			this->glProgramUniform1fv(var_program, var_location, var_count, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniform1fv");
			break;
		}
		case OP_glProgramUniform2fv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform2fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform2fv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform2fv(%u %d %d %p(%u) )\n", stream, var_program, var_location, var_count, (const GLfloat*)(inptr_value.get()), size_value);
			this->glProgramUniform2fv(var_program, var_location, var_count, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniform2fv");
			break;
		}
		case OP_glProgramUniform3fv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform3fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform3fv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform3fv(%u %d %d %p(%u) )\n", stream, var_program, var_location, var_count, (const GLfloat*)(inptr_value.get()), size_value);
			this->glProgramUniform3fv(var_program, var_location, var_count, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniform3fv");
			break;
		}
		case OP_glProgramUniform4fv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform4fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform4fv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform4fv(%u %d %d %p(%u) )\n", stream, var_program, var_location, var_count, (const GLfloat*)(inptr_value.get()), size_value);
			this->glProgramUniform4fv(var_program, var_location, var_count, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniform4fv");
			break;
		}
		case OP_glProgramUniform1iv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform1iv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform1iv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform1iv(%u %d %d %p(%u) )\n", stream, var_program, var_location, var_count, (const GLint*)(inptr_value.get()), size_value);
			this->glProgramUniform1iv(var_program, var_location, var_count, (const GLint*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniform1iv");
			break;
		}
		case OP_glProgramUniform2iv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform2iv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform2iv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform2iv(%u %d %d %p(%u) )\n", stream, var_program, var_location, var_count, (const GLint*)(inptr_value.get()), size_value);
			this->glProgramUniform2iv(var_program, var_location, var_count, (const GLint*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniform2iv");
			break;
		}
		case OP_glProgramUniform3iv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform3iv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform3iv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform3iv(%u %d %d %p(%u) )\n", stream, var_program, var_location, var_count, (const GLint*)(inptr_value.get()), size_value);
			this->glProgramUniform3iv(var_program, var_location, var_count, (const GLint*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniform3iv");
			break;
		}
		case OP_glProgramUniform4iv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform4iv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform4iv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform4iv(%u %d %d %p(%u) )\n", stream, var_program, var_location, var_count, (const GLint*)(inptr_value.get()), size_value);
			this->glProgramUniform4iv(var_program, var_location, var_count, (const GLint*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniform4iv");
			break;
		}
		case OP_glProgramUniform1uiv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform1uiv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform1uiv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform1uiv(%u %d %d %p(%u) )\n", stream, var_program, var_location, var_count, (const GLuint*)(inptr_value.get()), size_value);
			this->glProgramUniform1uiv(var_program, var_location, var_count, (const GLuint*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniform1uiv");
			break;
		}
		case OP_glProgramUniform2uiv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform2uiv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform2uiv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform2uiv(%u %d %d %p(%u) )\n", stream, var_program, var_location, var_count, (const GLuint*)(inptr_value.get()), size_value);
			this->glProgramUniform2uiv(var_program, var_location, var_count, (const GLuint*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniform2uiv");
			break;
		}
		case OP_glProgramUniform3uiv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform3uiv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform3uiv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform3uiv(%u %d %d %p(%u) )\n", stream, var_program, var_location, var_count, (const GLuint*)(inptr_value.get()), size_value);
			this->glProgramUniform3uiv(var_program, var_location, var_count, (const GLuint*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniform3uiv");
			break;
		}
		case OP_glProgramUniform4uiv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniform4uiv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniform4uiv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniform4uiv(%u %d %d %p(%u) )\n", stream, var_program, var_location, var_count, (const GLuint*)(inptr_value.get()), size_value);
			this->glProgramUniform4uiv(var_program, var_location, var_count, (const GLuint*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniform4uiv");
			break;
		}
		case OP_glProgramUniformMatrix2fv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniformMatrix2fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniformMatrix2fv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniformMatrix2fv(%u %d %d %d %p(%u) )\n", stream, var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glProgramUniformMatrix2fv(var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniformMatrix2fv");
			break;
		}
		case OP_glProgramUniformMatrix3fv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniformMatrix3fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniformMatrix3fv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniformMatrix3fv(%u %d %d %d %p(%u) )\n", stream, var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glProgramUniformMatrix3fv(var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniformMatrix3fv");
			break;
		}
		case OP_glProgramUniformMatrix4fv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniformMatrix4fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniformMatrix4fv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniformMatrix4fv(%u %d %d %d %p(%u) )\n", stream, var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glProgramUniformMatrix4fv(var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniformMatrix4fv");
			break;
		}
		case OP_glProgramUniformMatrix2x3fv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniformMatrix2x3fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniformMatrix2x3fv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniformMatrix2x3fv(%u %d %d %d %p(%u) )\n", stream, var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glProgramUniformMatrix2x3fv(var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniformMatrix2x3fv");
			break;
		}
		case OP_glProgramUniformMatrix3x2fv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniformMatrix3x2fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniformMatrix3x2fv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniformMatrix3x2fv(%u %d %d %d %p(%u) )\n", stream, var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glProgramUniformMatrix3x2fv(var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniformMatrix3x2fv");
			break;
		}
		case OP_glProgramUniformMatrix2x4fv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniformMatrix2x4fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniformMatrix2x4fv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniformMatrix2x4fv(%u %d %d %d %p(%u) )\n", stream, var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glProgramUniformMatrix2x4fv(var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniformMatrix2x4fv");
			break;
		}
		case OP_glProgramUniformMatrix4x2fv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniformMatrix4x2fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniformMatrix4x2fv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniformMatrix4x2fv(%u %d %d %d %p(%u) )\n", stream, var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glProgramUniformMatrix4x2fv(var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniformMatrix4x2fv");
			break;
		}
		case OP_glProgramUniformMatrix3x4fv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniformMatrix3x4fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniformMatrix3x4fv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniformMatrix3x4fv(%u %d %d %d %p(%u) )\n", stream, var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glProgramUniformMatrix3x4fv(var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniformMatrix3x4fv");
			break;
		}
		case OP_glProgramUniformMatrix4x3fv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_value __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glProgramUniformMatrix4x3fv: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glProgramUniformMatrix4x3fv\n", err);
		#endif
			DEBUG("gles2(%p): glProgramUniformMatrix4x3fv(%u %d %d %d %p(%u) )\n", stream, var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glProgramUniformMatrix4x3fv(var_program, var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glProgramUniformMatrix4x3fv");
			break;
		}
		case OP_glGetProgramInterfaceiv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_programInterface = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetProgramInterfaceiv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetProgramInterfaceiv\n", err);
		#endif
			DEBUG("gles2(%p): glGetProgramInterfaceiv(%u 0x%08x 0x%08x %p(%u) )\n", stream, var_program, var_programInterface, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetProgramInterfaceiv(var_program, var_programInterface, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetProgramInterfaceiv");
			break;
		}
		case OP_glGetProgramResourceiv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_programInterface = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_propCount = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_props __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			InputBuffer inptr_props(ptr + 8 + 4 + 4 + 4 + 4 + 4, size_props);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + size_props);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + size_props + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + size_props + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + size_props + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + size_props + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetProgramResourceiv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_params(&tmpBuf[0 + size_length], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetProgramResourceiv\n", err);
		#endif
			DEBUG("gles2(%p): glGetProgramResourceiv(%u 0x%08x %u %d %p(%u) %d %p(%u) %p(%u) )\n", stream, var_program, var_programInterface, var_index, var_propCount, (const GLenum*)(inptr_props.get()), size_props, var_bufSize, (GLsizei*)(outptr_length.get()), size_length, (GLint*)(outptr_params.get()), size_params);
			this->glGetProgramResourceiv(var_program, var_programInterface, var_index, var_propCount, (const GLenum*)(inptr_props.get()), var_bufSize, size_length == 0 ? nullptr : (GLsizei*)(outptr_length.get()), (GLint*)(outptr_params.get()));
			outptr_length.flush();
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetProgramResourceiv");
			break;
		}
		case OP_glGetProgramResourceIndex: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_programInterface = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_name __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_name(ptr + 8 + 4 + 4 + 4, size_name);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_name, ptr + 8 + 4 + 4 + 4 + size_name, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetProgramResourceIndex: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLuint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetProgramResourceIndex\n", err);
		#endif
			DEBUG("gles2(%p): glGetProgramResourceIndex(%u 0x%08x %p(%u) )\n", stream, var_program, var_programInterface, (const char*)(inptr_name.get()), size_name);
			*(GLuint *)(&tmpBuf[0]) = 			this->glGetProgramResourceIndex(var_program, var_programInterface, (const char*)(inptr_name.get()));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetProgramResourceIndex");
			break;
		}
		case OP_glGetProgramResourceLocation: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_programInterface = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_name __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_name(ptr + 8 + 4 + 4 + 4, size_name);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_name, ptr + 8 + 4 + 4 + 4 + size_name, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetProgramResourceLocation: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetProgramResourceLocation\n", err);
		#endif
			DEBUG("gles2(%p): glGetProgramResourceLocation(%u 0x%08x %p(%u) )\n", stream, var_program, var_programInterface, (const char*)(inptr_name.get()), size_name);
			*(GLint *)(&tmpBuf[0]) = 			this->glGetProgramResourceLocation(var_program, var_programInterface, (const char*)(inptr_name.get()));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetProgramResourceLocation");
			break;
		}
		case OP_glGetProgramResourceName: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_programInterface = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_length __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			uint32_t size_name __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetProgramResourceName: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_name;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_name(&tmpBuf[0 + size_length], size_name);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetProgramResourceName\n", err);
		#endif
			DEBUG("gles2(%p): glGetProgramResourceName(%u 0x%08x %u %d %p(%u) %p(%u) )\n", stream, var_program, var_programInterface, var_index, var_bufSize, (GLsizei*)(outptr_length.get()), size_length, (char*)(outptr_name.get()), size_name);
			this->glGetProgramResourceName(var_program, var_programInterface, var_index, var_bufSize, size_length == 0 ? nullptr : (GLsizei*)(outptr_length.get()), (char*)(outptr_name.get()));
			outptr_length.flush();
			outptr_name.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetProgramResourceName");
			break;
		}
		case OP_glBindImageTexture: {
			GLuint var_unit = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_texture = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_layered = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_layer = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			GLenum var_access = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 1 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 1 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBindImageTexture: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBindImageTexture\n", err);
		#endif
			DEBUG("gles2(%p): glBindImageTexture(%u %u %d %d %d 0x%08x 0x%08x )\n", stream, var_unit, var_texture, var_level, var_layered, var_layer, var_access, var_format);
			this->glBindImageTexture(var_unit, var_texture, var_level, var_layered, var_layer, var_access, var_format);
			SET_LASTCALL("glBindImageTexture");
			break;
		}
		case OP_glDispatchCompute: {
			GLuint var_num_groups_x = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_num_groups_y = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLuint var_num_groups_z = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDispatchCompute: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDispatchCompute\n", err);
		#endif
			DEBUG("gles2(%p): glDispatchCompute(%u %u %u )\n", stream, var_num_groups_x, var_num_groups_y, var_num_groups_z);
			this->glDispatchCompute(var_num_groups_x, var_num_groups_y, var_num_groups_z);
			SET_LASTCALL("glDispatchCompute");
			break;
		}
		case OP_glDispatchComputeIndirect: {
			GLintptr var_indirect = Unpack<GLintptr,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDispatchComputeIndirect: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDispatchComputeIndirect\n", err);
		#endif
			DEBUG("gles2(%p): glDispatchComputeIndirect(0x%08lx )\n", stream, var_indirect);
			this->glDispatchComputeIndirect(var_indirect);
			SET_LASTCALL("glDispatchComputeIndirect");
			break;
		}
		case OP_glBindVertexBuffer: {
			GLuint var_bindingindex = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_buffer = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLintptr var_offset = Unpack<GLintptr,uint32_t>(ptr + 8 + 4 + 4);
			GLintptr var_stride = Unpack<GLintptr,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glBindVertexBuffer: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glBindVertexBuffer\n", err);
		#endif
			DEBUG("gles2(%p): glBindVertexBuffer(%u %u 0x%08lx 0x%08lx )\n", stream, var_bindingindex, var_buffer, var_offset, var_stride);
			this->glBindVertexBuffer(var_bindingindex, var_buffer, var_offset, var_stride);
			SET_LASTCALL("glBindVertexBuffer");
			break;
		}
		case OP_glVertexAttribBinding: {
			GLuint var_attribindex = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_bindingindex = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttribBinding: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttribBinding\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttribBinding(%u %u )\n", stream, var_attribindex, var_bindingindex);
			this->glVertexAttribBinding(var_attribindex, var_bindingindex);
			SET_LASTCALL("glVertexAttribBinding");
			break;
		}
		case OP_glVertexAttribFormat: {
			GLuint var_attribindex = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_size = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_normalized = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			GLuint var_relativeoffset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 1 + 4, ptr + 8 + 4 + 4 + 4 + 1 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttribFormat: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttribFormat\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttribFormat(%u %d 0x%08x %d %u )\n", stream, var_attribindex, var_size, var_type, var_normalized, var_relativeoffset);
			this->glVertexAttribFormat(var_attribindex, var_size, var_type, var_normalized, var_relativeoffset);
			SET_LASTCALL("glVertexAttribFormat");
			break;
		}
		case OP_glVertexAttribIFormat: {
			GLuint var_attribindex = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_size = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_relativeoffset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexAttribIFormat: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexAttribIFormat\n", err);
		#endif
			DEBUG("gles2(%p): glVertexAttribIFormat(%u %d 0x%08x %u )\n", stream, var_attribindex, var_size, var_type, var_relativeoffset);
			this->glVertexAttribIFormat(var_attribindex, var_size, var_type, var_relativeoffset);
			SET_LASTCALL("glVertexAttribIFormat");
			break;
		}
		case OP_glVertexBindingDivisor: {
			GLuint var_bindingindex = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_divisor = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glVertexBindingDivisor: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glVertexBindingDivisor\n", err);
		#endif
			DEBUG("gles2(%p): glVertexBindingDivisor(%u %u )\n", stream, var_bindingindex, var_divisor);
			this->glVertexBindingDivisor(var_bindingindex, var_divisor);
			SET_LASTCALL("glVertexBindingDivisor");
			break;
		}
		case OP_glDrawArraysIndirect: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_indirect __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_indirect(ptr + 8 + 4 + 4, size_indirect);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_indirect, ptr + 8 + 4 + 4 + size_indirect, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawArraysIndirect: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawArraysIndirect\n", err);
		#endif
			DEBUG("gles2(%p): glDrawArraysIndirect(0x%08x %p(%u) )\n", stream, var_mode, (const void*)(inptr_indirect.get()), size_indirect);
			this->glDrawArraysIndirect(var_mode, (const void*)(inptr_indirect.get()));
			SET_LASTCALL("glDrawArraysIndirect");
			break;
		}
		case OP_glDrawArraysIndirectDataAEMU: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_indirect __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_indirect(ptr + 8 + 4 + 4, size_indirect);
			GLuint var_datalen = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + size_indirect);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_indirect + 4, ptr + 8 + 4 + 4 + size_indirect + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawArraysIndirectDataAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawArraysIndirectDataAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glDrawArraysIndirectDataAEMU(0x%08x %p(%u) %u )\n", stream, var_mode, (const void*)(inptr_indirect.get()), size_indirect, var_datalen);
			this->glDrawArraysIndirectDataAEMU(this, var_mode, (const void*)(inptr_indirect.get()), var_datalen);
			SET_LASTCALL("glDrawArraysIndirectDataAEMU");
			break;
		}
		case OP_glDrawArraysIndirectOffsetAEMU: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawArraysIndirectOffsetAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawArraysIndirectOffsetAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glDrawArraysIndirectOffsetAEMU(0x%08x %u )\n", stream, var_mode, var_offset);
			this->glDrawArraysIndirectOffsetAEMU(this, var_mode, var_offset);
			SET_LASTCALL("glDrawArraysIndirectOffsetAEMU");
			break;
		}
		case OP_glDrawElementsIndirect: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_indirect __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_indirect(ptr + 8 + 4 + 4 + 4, size_indirect);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_indirect, ptr + 8 + 4 + 4 + 4 + size_indirect, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawElementsIndirect: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawElementsIndirect\n", err);
		#endif
			DEBUG("gles2(%p): glDrawElementsIndirect(0x%08x 0x%08x %p(%u) )\n", stream, var_mode, var_type, (const void*)(inptr_indirect.get()), size_indirect);
			this->glDrawElementsIndirect(var_mode, var_type, (const void*)(inptr_indirect.get()));
			SET_LASTCALL("glDrawElementsIndirect");
			break;
		}
		case OP_glDrawElementsIndirectDataAEMU: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_indirect __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_indirect(ptr + 8 + 4 + 4 + 4, size_indirect);
			GLuint var_datalen = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_indirect);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + size_indirect + 4, ptr + 8 + 4 + 4 + 4 + size_indirect + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawElementsIndirectDataAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawElementsIndirectDataAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glDrawElementsIndirectDataAEMU(0x%08x 0x%08x %p(%u) %u )\n", stream, var_mode, var_type, (const void*)(inptr_indirect.get()), size_indirect, var_datalen);
			this->glDrawElementsIndirectDataAEMU(this, var_mode, var_type, (const void*)(inptr_indirect.get()), var_datalen);
			SET_LASTCALL("glDrawElementsIndirectDataAEMU");
			break;
		}
		case OP_glDrawElementsIndirectOffsetAEMU: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glDrawElementsIndirectOffsetAEMU: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glDrawElementsIndirectOffsetAEMU\n", err);
		#endif
			DEBUG("gles2(%p): glDrawElementsIndirectOffsetAEMU(0x%08x 0x%08x %u )\n", stream, var_mode, var_type, var_offset);
			this->glDrawElementsIndirectOffsetAEMU(this, var_mode, var_type, var_offset);
			SET_LASTCALL("glDrawElementsIndirectOffsetAEMU");
			break;
		}
		case OP_glTexStorage2DMultisample: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_samples = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLboolean var_fixedsamplelocations = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 1, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 1, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glTexStorage2DMultisample: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glTexStorage2DMultisample\n", err);
		#endif
			DEBUG("gles2(%p): glTexStorage2DMultisample(0x%08x %d 0x%08x %d %d %d )\n", stream, var_target, var_samples, var_internalformat, var_width, var_height, var_fixedsamplelocations);
			this->glTexStorage2DMultisample(var_target, var_samples, var_internalformat, var_width, var_height, var_fixedsamplelocations);
			SET_LASTCALL("glTexStorage2DMultisample");
			break;
		}
		case OP_glSampleMaski: {
			GLuint var_maskNumber = Unpack<GLuint,uint32_t>(ptr + 8);
			GLbitfield var_mask = Unpack<GLbitfield,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glSampleMaski: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glSampleMaski\n", err);
		#endif
			DEBUG("gles2(%p): glSampleMaski(%u 0x%08x )\n", stream, var_maskNumber, var_mask);
			this->glSampleMaski(var_maskNumber, var_mask);
			SET_LASTCALL("glSampleMaski");
			break;
		}
		case OP_glGetMultisamplefv: {
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			uint32_t size_val __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetMultisamplefv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_val;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_val(&tmpBuf[0], size_val);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetMultisamplefv\n", err);
		#endif
			DEBUG("gles2(%p): glGetMultisamplefv(0x%08x %u %p(%u) )\n", stream, var_pname, var_index, (GLfloat*)(outptr_val.get()), size_val);
			this->glGetMultisamplefv(var_pname, var_index, (GLfloat*)(outptr_val.get()));
			outptr_val.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetMultisamplefv");
			break;
		}
		case OP_glFramebufferParameteri: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLint var_param = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glFramebufferParameteri: GL checksumCalculator failure\n");
			}
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glFramebufferParameteri\n", err);
		#endif
			DEBUG("gles2(%p): glFramebufferParameteri(0x%08x 0x%08x %d )\n", stream, var_target, var_pname, var_param);
			this->glFramebufferParameteri(var_target, var_pname, var_param);
			SET_LASTCALL("glFramebufferParameteri");
			break;
		}
		case OP_glGetFramebufferParameteriv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetFramebufferParameteriv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetFramebufferParameteriv\n", err);
		#endif
			DEBUG("gles2(%p): glGetFramebufferParameteriv(0x%08x 0x%08x %p(%u) )\n", stream, var_target, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetFramebufferParameteriv(var_target, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetFramebufferParameteriv");
			break;
		}
		case OP_glGetTexLevelParameterfv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetTexLevelParameterfv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetTexLevelParameterfv\n", err);
		#endif
			DEBUG("gles2(%p): glGetTexLevelParameterfv(0x%08x %d 0x%08x %p(%u) )\n", stream, var_target, var_level, var_pname, (GLfloat*)(outptr_params.get()), size_params);
			this->glGetTexLevelParameterfv(var_target, var_level, var_pname, (GLfloat*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetTexLevelParameterfv");
			break;
		}
		case OP_glGetTexLevelParameteriv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_params __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"gles2_decoder_context_t::decode, OP_glGetTexLevelParameteriv: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (pre-call): 0x%X before glGetTexLevelParameteriv\n", err);
		#endif
			DEBUG("gles2(%p): glGetTexLevelParameteriv(0x%08x %d 0x%08x %p(%u) )\n", stream, var_target, var_level, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetTexLevelParameteriv(var_target, var_level, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetTexLevelParameteriv");
			break;
		}
		default:
			return ptr - (unsigned char*)buf;
		} //switch
		#ifdef CHECK_GL_ERRORS
		GLint err = this->glGetError();
		if (err) fprintf(stderr, "gles2 Error (post-call): 0x%X in %s\n", err, lastCall);
		#endif
		ptr += packetLen;
	} // while
	return ptr - (unsigned char*)buf;
}
